# 买卖股票的最佳时机系列

## 121、买卖股票的最佳时机（一次交易）

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

示例 1:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```


示例 2:

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```





### 方法：一次遍历

假设给定的数组为：`[7, 1, 5, 3, 6, 4]`

如果我们在图表上绘制给定数组中的数字，我们将会得到：

![Profit Graph](https://gitee.com/zero049/MyNoteImages/raw/master/cc4ef55d97cfef6f9215285c7573027c4b265c31101dd54e8555a7021c95c927-file_1555699418271)

我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 `i` 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？

显然，我们只需要找一个第 `i` 天之前的最低点买入，那么在第 `i` 天卖出，就能获得利益最大化，我们只需要记录着个利益的最大值即可。

代码如下

```java
public class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len <= 1) {
            return 0;
        }
        int minPrice = Integer.MAX_VALUE;				// 记录到i为止的最小值
        int maxP = 0;
        for (int i = 0; i < len; ++i) {
            if (minPrice > prices[i]) {
                minPrice = prices[i];
            }
            maxP = Math.max(maxP, prices[i] - minPrice);
        }
        return maxP;
 }
}
```

**复杂度分析**

时间复杂度：O(n)，只需要遍历一次。

空间复杂度：O(1)，只使用了常数个变量。



## 122、买卖股票的最佳时机（无限次）

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4



### 方法一：画图分析——峰谷法

假设给定的数组为：

[7, 1, 5, 3, 6, 4]

如果我们在图表上绘制给定数组中的数字，我们将会得到：

![](https://gitee.com/zero049/MyNoteImages/raw/master/20200915135235.png)

如果我们分析图表，那么我们的兴趣点是**连续的峰和谷。**

**关键是我们需要考虑到紧跟谷的每一个峰值以最大化利润。如果我们试图跳过其中一个峰值来获取更多利润，那么我们最终将失去其中一笔交易中获得的利润，从而导致总利润的降低。**

例如，在上述情况下，如果我们跳过 peak 和 valley试图通过考虑差异较大的点以获取更多的利润，获得的净利润总是会小与包含它们而获得的净利润，因为 C 总是小于 A+B。

上述思想符合贪心算法，难点在于代码如何实现找峰值和谷值

代码如下

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int len = prices.length;
        int profit = 0;
        int valley = prices[0];
        int peak = prices[0];
        int i = 0;
        while (i < len - 1) {

            while (i < len - 1 && prices[i] >= prices[i + 1]) {	// 先找一个谷
                ++i;
            }
            valley = prices[i];

            while (i < len - 1 && prices[i] <= prices[i + 1]) {	// 接着找峰，那么峰一定在谷后面
                ++i;
            }
            peak = prices[i];
            
            profit += (peak-valley);
        }
        return profit;
    }
}
```

**复杂度分析**

时间复杂度：O(n)。遍历一次。

空间复杂度：O(1)。需要常量的空间。



### 方法二：简单的一次遍历

该解决方案遵循 方法二 的本身使用的逻辑，但有一些轻微的变化。在这种情况下，我们可以简单地继续在斜坡上爬升并持续增加从连续交易中获得的利润，而不是在谷之后寻找每个峰值。最后，我们将有效地使用峰值和谷值，但我们不需要跟踪峰值和谷值对应的成本以及最大利润，但我们可以直接继续增加加数组的连续数字之间的差值，如果第二个数字大于第一个数字，我们获得的总和将是最大利润。这种方法将简化解决方案。
这个例子可以更清楚地展现上述情况：

[1, 7, 2, 3, 6, 7, 6, 7]

与此数组对应的图形是：

![](https://gitee.com/zero049/MyNoteImages/raw/master/20200915135828.png)

从上图中，我们可以观察到 A+B+C 的和等于差值 D 所对应的连续峰和谷的高度之差。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1])
                maxprofit += prices[i] - prices[i - 1];
        }
        return maxprofit;
    }
}
```





## 123、买卖股票的最佳时机（最多两次交易）

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

示例 2:

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例 3:

```
输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```





### 方法一：递归

之前的股票系列题目可以无限次数的买卖、或者只能买卖一次，很显然**买卖两次的状态转换就比之前要复杂多了，这也就是本题的难点所在。**
需要注意的是，我们最终求出的最大利润，**不一定非得交易两次，也可能一次都不交易(行情不好不炒股了)，或者只交易了一次(如示例2)。**

我们先看一下，买卖两次时是怎么进行状态转换的

![1.jpg](https://gitee.com/zero049/MyNoteImages/raw/master/5c8147c0cf4899ba692d7d7853e7df9f15faea4b013591d60af225b751fa27fc-1.jpg)

一开始处于初始状态，也就是什么都不做，不买也不卖

初始状态只能转向**买入1**状态(第一次买入股票)，也就是买入一股；当买入一股后，我们有两种选择:

- 可以立马转向卖出1状态(第一次卖出股票)
- 或者转入保持不动状态，相当于手里一直有这一股，等待一个好时机之后再卖出。

在**卖出1**状态时:

- 我们可以立马转入买入2状态(第二次买入股票)
- 或者转入保持不动状态，相当于此时手里没有股票了，等待一个好时机后再买入。

买入2和卖出2也是类似的

卖出2执行完后，就只能转入到**交易结束**状态了，后面就无法再买卖了。

通过上面的这个状态转换图，我们可以用三个变量来表示买卖两次的交易状态

- index，用来表示当前是哪一天
- status，用来表示当前状态是买入、还是卖出
- k，用来表示交易了几次

如果状态是是买入:

- 那么可以保持不动
- 或者马上卖掉

如果状态是卖出:

- 可以保持不动(等待更好的股价出现，暂时不买)
- 或者立马再买一股

同时将count数+1，表示交易过一次了

对于数组[1,2,3,4,5]其递归调用树如下:

![2.jpg](https://gitee.com/zero049/MyNoteImages/raw/master/ae4e5a93ca28edcd7a5dbaeec0507f1bba7d315168bc6f691c40ca1b09c3b5ac-2.jpg)

第一次只能买入，对应上图也就是节点1的买1，当然也可以选择不买，也就是不动。

第一次买之后可以立刻卖掉，也就是上图中 根 --买1--> 1 --卖1--> 2这条路线。这就对应了第一张图中买入1转换到卖出1的过程。

或者也可以选择不动，对应到上图就是根 --买1--> 1 --不动--> 2这条路线。对应第一张图中买1后转入到保持不动这个过程。

卖1 到 买2、以及买2 到卖2 这之间的转换关系也是类似的，这里的调用链太长了我就没画了，大家可以看下图一和图二，对比一下这个关系。

第二次卖出后就无法再交易了，所以从调用树上来看，后面就不会再有调用的子节点了。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length==0) {
            return 0;
        }
        int n = prices.length;
        return dfs(prices,0,0,0);
    }
	
    private int dfs(int[] prices,int index,int status,int k) {
        //递归终止条件，数组执行到头了，或者交易了两次了
        if(index==prices.length || k==2) {
            return 0;
        }
        //定义三个变量，分别记录[不动]、[买]、[卖]
        int a=0,b=0,c=0;
        //保持不动
        a = dfs(prices,index+1,status,k);
        if(status==1) {
            //递归处理卖的情况，这里需要将k+1，表示执行了一次交易
            b = dfs(prices,index+1,0,k+1)+prices[index];
        }
        else {
            //递归处理买的情况
            c = dfs(prices,index+1,1,k)-prices[index];
        }
        //最终结果就是三个变量中的最大值
        return Math.max(Math.max(a,b),c);
    }
}
```



### 方法二：动态规划——未优化三维数组

在递归实现时，我们用了三个变量：index、k、status。这里我们定义一个三维数组
`dp[i][j][k]` 这里的 i 表示天数， j 表示交易次数，k表示状态，0代表不持有股票，1代表持有股票

- `dp[i][0][0]`：表示第i天交易了0次时卖出后的累计最大利润
- `dp[i][0][1]`：表示第i天交易了0次时买入后的累计最大利润
- `dp[i][1][0]`：表示第i天交易了1次时卖出后的累计最大利润
- `dp[i][1][1]`：表示第i天交易了1次时买入后的累计最大利润
- `dp[i][2][0]`：表示第i天交易了2次时卖出后的累计最大利润
- `dp[i][2][1]`：表示第i天交易了2次时买入后的累计最大利润

注意，最后一个`dp[i][2][1]` 实际是不存在的，因为交易两次后，就不能再买入了。

我们来分析一下上面定义的dp数组：


![4.jpg](https://gitee.com/zero049/MyNoteImages/raw/master/f11fe32b226215bf37e7704b55ac184a98905033951755b8232fdccd2ad56973-4.jpg)

- `dp[i][0][0]`：对应于初始状态，第i天0次交易卖出，既然都没交易，那何来卖出呢，所以只能是0。
- `dp[i][0][1]`和`dp[i][1][0]` 这两个是一对，对应到上图中就是第一次买入、第一次卖出。
- `dp[i][1][1]`和`dp[i][2][0]` 这两个也是一对，对应到上图中就是第二次买入、第二次卖出。

从这里我们也能看出为什么`dp[i][2][1]`是无效的。交易完两次后，再持有股票也没用

代码

```java
class Solution {
    public int maxProfit(int[] prices) {
       if(prices==null || prices.length==0) {
            return 0;
        }
        int n = prices.length;
        //定义三维数组，第i天、交易了多少次、当前的买卖状态
        int[][][] dp = new int[n][3][2];
        //初始化第一天，这里的dp[0][2][1]可以不用管，后面也不会用到
        dp[0][0][0] = 0;
        dp[0][0][1] = -prices[0];						// 买
        dp[0][1][0] = 0;
        dp[0][1][1] = -prices[0];						// 相当于准备只买一次
        dp[0][2][0] = 0;
        dp[0][2][1] = -prices[0];						// 买了两次的，还要买的就没有意义了
        for(int i=1;i<n;++i) {
            //dp[i][0][0]相当于初始状态，它只能从初始状态转换来
            dp[i][0][0] = dp[i-1][0][0];						// 从头就不买，可以省略，一直为0
            //处理第一次买入、第一次卖出
            dp[i][0][1] = Math.max(dp[i-1][0][1],dp[i-1][0][0]-prices[i]);		// 持有，或买入
            dp[i][1][0] = Math.max(dp[i-1][1][0],dp[i-1][0][1]+prices[i]);
            //处理第二次买入、第二次卖出
            dp[i][1][1] = Math.max(dp[i-1][1][1],dp[i-1][1][0]-prices[i]);
            dp[i][2][0] = Math.max(dp[i-1][2][0],dp[i-1][1][1]+prices[i]);
        }
        //返回最大值
        int a = 0;              							// 一次不买
        int b = dp[n-1][1][0];      						// 买一次
        return Math.max(Math.max(a,b),dp[n-1][2][0]);       // 再比较买2次
    }
}
```



### 方法二：动态规划——稍微优化的二维数组

这我们定义一个二维数组` dp[n][5]`，上面三维数组有6种状态（2*3）其实只有4个位置是动态变化的（`dp[i][0][0]`和`dp[0][2][1]`不会变化），这里还是把一个不买的空间算上了

这的n表示天数，5表示5种不同的状态

代码如下

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int n = prices.length;
        int[][] dp = new int[n][5];

        dp[0][0] = 0;                       // 一个不买
        dp[0][1] = -prices[0];
        dp[0][2] = 0;                       // 买了一个了
        dp[0][3] = -prices[0];
        dp[0][4] = 0;                       // 买了两个了

        for (int i = 1; i < n; ++i) {
			//处理第一次买入、第一次卖出
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i][1] + prices[i]);
			//处理第二次买入、第二次卖出
            dp[i][3] = Math.max(dp[i - 1][3], dp[i][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i][3] + prices[i]);
        }
        return Math.max(0,Math.max(dp[n-1][2],dp[n-1][4]));
    }
}
```



### 方法二：动态规划——常数空间

实际上在动态变化的只有4个，因此我们只需要4个变量去改就行

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int n = prices.length;

        int dp1 = -prices[0];
        int dp2 = 0;
        int dp3 = -prices[0];
        int dp4 = 0;

        for (int i = 1; i < n; ++i) {
            dp1 = Math.max(dp1, -prices[i]);
            dp2 = Math.max(dp2, dp1 + prices[i]);
            dp3 = Math.max(dp3, dp2 - prices[i]);
            dp4 = Math.max(dp4, dp3 + prices[i]);
        }

        return Math.max(0, Math.max(dp2, dp4));
    }
}
```





## 309、买卖股票的最佳时机（含冷冻期）

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```



### 方法：动态规划

我们用 dp[i] 表示第 i 天结束之后的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：

- 我们目前买了一支股票，对应的「累计最大收益」记为`dp[i][0]`；
- 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为`dp[i][1]`；
- 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 `dp[i][2]`。

那么如何进行状态转移呢？

**1、对于持有股票时的状态转移**

对于持有股票的状态来源，主要有两种，一种是前面就买了，现在维持现状，另一种是我冷冻期结束了，可以再买一个合适的股票

既然有这两种状态，我们只需要能拿到最多钱的那种方案即可，即取Max

- 前面买了，持有股票，维持现状，那就是`dp[i][0] = dp[i-1][0]`
- 前面交易全完成了，冷冻期也结束了，我现在可以再买一只股票`dp[i][0] = dp[i-1][2] - price[i]`

综上，`dp[i][0]`的状态转移如下：

```
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2]-prices[i]);
```



**2、对于不持有股票，并处于冷冻期的状态转移**

对于不持有股票，并处于冷冻期的状态来源，是因为我当天卖了一只股票，第二天不能再买，所以卖股票这件事，是从持有股票的状态转移过的，且哪天卖都没有关系（只可能影响再买入操作）

```
dp[i][1] = dp[i-1][0] + price[i]
```



**3、对于不持有股票，且不处于冷冻期的状态转移**

对于不持有股票，且不处于冷冻期的状态来源，一是我冷冻期结束了（过了一天，收益不会变化），二是我压根就没买和卖

- 冷却期结束`dp[i][2] = dp[i-1][1]`

- 压根没买和卖`dp[i][2] = dp[i-1][2]`

综上，`dp[i][2]`的状态转移如下：

```
dp[i][2] = Math.max(dp[i-1][1],dp[i-1][2]);
```

重要的是，最后更新完`dp[i][2]`后，进入下一天，又可以进行买股票了，`dp[i][0]`得以更新

如下图所示：

![309最佳买卖股票时机含冷冻期图解图.png](pictures/7ae8b65cf80c5e9980ea33973abb6678f10098646aeac699cac12817b7e250ce-309最佳买卖股票时机含冷冻期图解图.png)

最终，最大利润可能是最后一天卖完处于冷冻期的`dp[n-1][1]`，也可能是过完冷冻期了的`dp[n-1][2]`，由于卖完处于冷冻期的，只记录卖出能获得的收益。

现在以`{1,2,3,0,2}`为例

```
		1       2       3       0       2
		
dp[0]  -1      -1      -1       1       1
dp[1]	0       1       2      -1       3
dp[2]	0       0       1       2       2
```

dp[0] = 1的更新是因为dp[2]完成了前一天冷却期，可以再买入



代码:

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int profit = 0;
        if(len==0){
            return profit;
        }
        int[][] dp = new int[len][3];
        dp[0][0] = -prices[0];
        for(int i=1;i<len;++i){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2]-prices[i]);
            dp[i][1] = dp[i-1][0] + prices[i];
            dp[i][2] = Math.max(dp[i-1][1],dp[i-1][2]);
        }

        return Math.max(dp[len-1][1],dp[len-1][2]);
    }
}
```

时间复杂度O(n) for循环处

空间复杂度O(n) dp数组的使用

优化空间：

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) return 0;
        int dp0 = -prices[0], dp1 = 0, dp2 = 0;
        for (int i = 1; i < prices.length; i++) {
            int temp0 = Math.max(dp0, dp2 - prices[i]);
            int tmep1 = dp0 + prices[i];
            int temp2 = Math.max(dp1, dp2);
            dp0 = temp0;
            dp1 = tmep1;
            dp2 = temp2;
        }
        int maxProfit = Math.max(dp1, dp2);
        return maxProfit;
    }
}
```

时间复杂度O(n) for循环处

空间复杂度O(1) 只需要额外个别的存储变量空间