# 287、寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1:**

```
输入: [1,3,4,2,2]
输出: 2
```

**示例 2:**

```
输入: [3,1,3,4,2]
输出: 3
```

**说明：**

- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n^2^) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。



## 题解

### 方法一：二分查找+频数统计

由于整型数组中其数字都在 1 到 n 之间（包括 1 和 n），包含 n + 1 个整数

那么我们对一个下标 `i` 进行统计比`i` 还小元素个数，比如下面的数组

```
[3,1,3,4,2]
 0 1 2 3 4			// 下标
```

假如我们选择下标2，进行统计那么小于等于2的数一共有1,2，共两个，说明 1，2 肯定不是重复元素（因为刚好各一个）

假如我们选择下标3，进行统计小于等于3的数一共有4个（1，2，3，3），**说明包括3的左边一定有重复元素**，如果结合上面选择下标2的结果，那我们就能得到，重复元素为3。

这是根据数字都在 1 到 n 之间的性质进行频数统计的方法，通过二分查找减少时间复杂度，其实下标就相当于在找数了

下面以`{3,3,3,3,1,2}`为例

```java
{ 3, 3, 3, 3, 1, 2}
     ↑	   ↑     ↑       下标3
统计得6，说明重复值出现了，往左边找，缩小范围，先赋值为3
{ 3, 3, 3, 3, 1, 2}
  	 ↑  ↑       		下标1        
统计得1，说明不是下标1，往右边找      
{ 3, 3, 3, 3, 1, 2}
  	   ↑       		    下标2    
统计得2，说明不是下标2，left>right，退出  
```

代码如下

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int len = nums.length;
        int left = 1;								// 从1取是因为数组不会有0，有时可以减一次循环次数
        int right = len - 1;
        int ans = 0;
        while (left <= right) {
            int mid = (left + right) >> 1;				// 频数统计
            int count = 0;
            for (int i = 0; i < len; ++i) {
                if (nums[i] <= mid) {
                    ++count;
                }
            }

            if (count <= mid) {					// 小于等于则说明左边已经不存在重复值了
                left = mid + 1;
            } else {							// 大于，说明肯定有重复值
                right = mid - 1;				
                ans = mid;						// 先给当前下标，后面可能左边的都不成立
            }
        }
        return ans;
    }
}
```

**复杂度分析**

时间复杂度：O(nlogn)，其中 n 为 nums[] 数组的长度。二分查找最多需要二分 O(logn) 次，每次判断的时候需要O(n)遍历 nums[] 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 O(nlogn)。

空间复杂度：O(1)O(1)。我们只需要常数空间存放若干变量。



### 方法二：二进制（TODO）

这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 1 还是 0 就可以按位还原出重复的数是什么。

考虑到第 i 位，我们记 nums[] 数组中二进制展开后第 i 位为 1 的数有 x 个，数字 [1,n] 这 n 个数（无重复）二进制展开后第 i 位为 1 的数有 y 个，那么重复的数第 i 位为 1 当且仅当 x>y。

以示例 1 为例，如下的表格列出了每个数字二进制下每一位是 1 还是 0 以及对应位的 x 和 y 是多少：

|         |  1   |  3   |  4   |  2   |  2   |  x   |  y   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 第 0 位 |  1   |  1   |  0   |  0   |  0   |  2   |  2   |
| 第 1 位 |  0   |  1   |  0   |  1   |  1   |  3   |  2   |
| 第 2 位 |  0   |  0   |  1   |  0   |  0   |  1   |  1   |

最后每一位多的再还原成一个数，那个数就是多的

代码如下

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int len = nums.length;
        int ans = 0;
        int bit_max = 31;
        while (((len - 1) >> bit_max) == 0) {            // 数组最大值n可以右移的最大位数
            bit_max -= 1;
        }
        for (int bit = 0; bit <= bit_max; ++bit) {
            int x = 0, y = 0;
            for (int i = 0; i < len; ++i) {
                if ((nums[i] & (1 << bit)) != 0) {              // 求num[i] 第bit位的1的总数
                    x += 1;
                }
                if (i >= 1 && ((i & (1 << bit)) != 0)) {
                    y += 1;
                }
            }
            if (x > y) {                            // 按位还原
                ans |= 1 << bit;
            }
        }
        return ans;
    }
}
```

**复杂度分析**

时间复杂度：O(nlogn)，其中 n 为nums[] 数组的长度。O(logn) 代表了我们枚举二进制数的位数个数，枚举第 i 位的时候需要遍历数组统计 x 和 y 的答案，因此总时间复杂度为 O(nlogn)。

空间复杂度：O(1)。我们只需要常数空间存放若干变量。



### 方法三：快慢指针

本方法需要读者对 「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解，它是一个检测链表是否有环的算法，LeetCode 中相关例题有 [50. 环形链表](50、环形链表.md)，[51. 环形链表2](51、环形链表2.md)

**我们对 `nums[]` 数组建图，每个位置 i 连一条 `i→nums[i] `的边。由于存在的重复的数字 `target`，因此 `target` 这个位置一定有起码两条指向它的边，因此整张图一定存在环**，且我们要找到的 `target` 就是这个环的入口，那么整个问题就等价于 142. 环形链表 II。

我们先设置慢指针 `slow` 和快指针 `fast` ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 `slow` 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。

这里展示数组链化的图示

![image-20200914165139183](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200914165139183.png)

代码如下：

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = nums[0];
        int fast = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);					// 找相遇点

        fast = nums[0];
        while(slow!=fast){
            fast = nums[fast];
            slow = nums[slow];
        }
        return slow;
    }
}
```

**复杂度分析**

时间复杂度：O(n)。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。

空间复杂度：O(1)。我们只需要常数空间存放若干变量。

