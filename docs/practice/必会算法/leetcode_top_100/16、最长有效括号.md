# 32、最长有效括号

给定一个只包含` '(' `和` ')' `的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

示例 2:

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```





## 题解

### 方法一：栈

通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。

具体做法是我们始终保持**栈底元素**为当前已经遍历过的元素中**「最后一个没有被匹配的右括号的下标」**，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

- 对于遇到的每个 ` '(' ` ，我们将它的下标放入栈中
- 对于遇到的每个 ` ')' ` ，我们先弹出栈顶元素表示匹配了当前右括号：
  - **如果栈为空，说明当前的右括号在栈中没有匹配的左括号，为无法匹配的右括号，可以作为一道分割线，后面形成的括号对从这里开始计数**，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
  - **如果栈不为空**，当前右括号的下标减去栈顶元素即为**「以该右括号为结尾的最长有效括号的长度」**

我们从前往后遍历字符串并更新答案即可。

需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为−1 的元素。

代码如下

```java
class Solution {
    public int longestValidParentheses(String s) {
       if (s == null || s.length() <= 1) {
            return 0;
        }

        Stack<Integer> stack = new Stack<>();
        stack.push(-1);

        int len = s.length();
        int max = 0;

        for (int i = 0; i < len; ++i) {
            if (s.charAt(i) == '(') {		 		// 当前字符为'('，下标入栈
                stack.push(i);
            }else if (s.charAt(i) == ')') {			// 当前字符为')'
                stack.pop();						// 无论栈顶是'('或')'的下标，都弹出
                if (stack.isEmpty()) {				// 弹出后，弹出栈底了，才会是空（把-1或最近的不匹配右括号下标弹出）
                    stack.push(i);					// 最近的不匹配右括号下标
                } else {							// 弹出后，不为空，说明匹配了一个左括号，进行计算
                    max = Math.max(max, i-stack.peek());
                }
            }else{
                return 0;
            }
            
        }
        return max;
    }

}
```

**复杂度分析**

时间复杂度：O（n），n是给定字符串的长度。我们只需要遍历字符串一次即可

空间复杂度：O（n）。栈的大小在最坏情况下会达到n，因此空间复杂度为O（n）



### 方法二：动态规划

结合确定「最后一个没有被匹配的右括号的下标」的思想，这题也可以通过动态规划来做

我们**用`dp[i]`来表示以下标 `i`结尾的 到最后一个没有被匹配的右括号的下标的长度。**

1、对于`s.charAt(i)=='('`

- 显然，有效的子串一定以` ')' ` 结尾，因此我们可以知道以` '(' ` 结尾的子串对应的dp 值必定为 0 ，我们只需要求解` ')' ` 在 dp 数组中对应位置的值。

2、对于`s.charAt(i)==')'`

- 如果`s.charAt(i)==')'`且`s.charAt(i-1)=='('`，形如

  ```
  "()()"
      ↑
  "())()"
       ↑
  ```

  当下标i超过2，显然当前下标 `i`结尾的 到最后一个没有被匹配的右括号的下标的长度是需要参考其左括号前的匹配情况的

  ```
  "()()"
    ↑ ↑
    2 4 
  "())()"
     ↑ ↑
     0 4
  ```

  我们可以推出

  ```java
  dp[i] = dp[i-2]+2				if i>2
  ```

- 如果`s.charAt(i)==')'`且`s.charAt(i-1)==')'`，形如

  ```
  "()())"
       ↑
  "()))()"
     ↑
  "()(())"
        ↑
  ```

  要想能进行匹配，那么必须有`s.charAt(i-dp[i-1]-1)=='('`，即到下标`i-1`匹配的是下标`i`括号内部的成员，要跨过内部成员找到成员前面那个`'('`

  ```
  "(()())"	----> √，内部成员"()()"
   ↑   ↑↑
   0   45  -------> 下标，这里下标为4的，匹配长度也是4     
  "()))()"--------> ×，由于不存在对应的左括号
    ↑↑
    20    -------> 匹配长度
  "()(())"	----> √，内部成员"()"
    ↑↑ ↑↑
    2  26 -------> 匹配长度
  ```

  对于匹配的内部成员加上自身的匹配长度，我们可以推出

  ```java
  dp[i] = dp[i-1] + 2					if i-dp[i-1]-1>=0
  ```

  但字符串可能不仅包含内部成员，可能外部成员也是匹配的如上面第三个字符串里的第一个对括号，与该次匹配的括号属于并列关系，因此表达式还需要加入外部成员的匹配长度

  ```java
  dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2		if i-dp[i-1]-2>0
  ```

结合上述分析，例子如下：

```
0 1 2 3 4 5 6 7					下标
( ) ) ( ( ( ) )
0 2 0 0 0 0 2 4                 匹配长度
```

代码如下

```java
class Solution {
    public int longestValidParentheses(String s) {
        if (s == null || s.length() <= 1) {
            return 0;
        }
        int len = s.length();
        int[] dp = new int[len];
        int max = 0;
        for (int i = 1; i < len; ++i) {
            if (s.charAt(i) == ')') {					// 只有以')'结尾的子串才需要判断
                if (s.charAt(i - 1) == '(') {			// 符合上述情况2的第一种
                    if (i - 2 > 0) {
                        dp[i] = dp[i - 2] + 2;			// 参考前面并列关系的+2
                    } else {
                        dp[i] = 2;						// 不够长不能参考，直接是2
                    }
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {	// 符合情况2的第二种
                    if (i - dp[i - 1] - 2 > 0) {
                        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;
                    } else {
                        dp[i] = dp[i - 1] + 2;			// 不够长不能参考
                    }
                }
                max = Math.max(max, dp[i]);				// 只有以')'结尾的子串才需要做判断
            }
        }
        return max;
    }
}
```

**复杂度分析**

时间复杂度：O（n），其中n为字符串的长度。我们只需遍历整个字符串一次，即可将dp数组求出来。

空间复杂度：O（n）。我们需要一个大小为n的dp数组。



### 方法三：贪心算法

在此方法中，我们利用两个计数器`left`和 `right`。首先，我们从左到右遍历字符串，对于遇到的每个`'('`，我们增加`left`计数器，对于遇到的每个`)`，我们增加 `right`计数器。每当`left`计数器与 `right`计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当`right`计数器比`left`计数器大时，我们将`left`和 `right`计数器同时变回0

这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，**每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑**，重新从下一个字符开始计算，但这样会漏掉种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即`"(()"`，这种时候最长有效括号是求不出来的。

解决的方法也很简单，我们只需要**从右往左遍历用类似的方法计算**即可，只是这个时候判断条件反了过来：

- 当lef计数器比righ计数器大时，我们将le和 right计数器同时变回0
- 当lef计数器与 right计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符这样我们就能涵盖所有情况从而求解出答案。



代码

```java
class Solution {
    public int longestValidParentheses(String s) {
        if (s == null || s.length() <= 1) {
            return 0;
        }
        int len = s.length();
        int max = 0;
        int left = 0;
        int right = 0;
        // 从左往右遍历，无法判断"((())"这种情况
        for (int i = 0; i < len; ++i) {
            if(s.charAt(i)=='('){
                ++left;
            }else if(s.charAt(i)==')'){
                ++right;
            }else{
                return 0;
            }

            if(left==right){
                max = Math.max(max,left+right);
            }else if(left<right){			// 右括号多，重置
                left = 0;
                right = 0;
            }
        }
        left=0;
        right=0;
        // 从右往左遍历，无法判断"(()))"这种情况
        for (int i = len-1; i >= 0; --i) {
            if(s.charAt(i)=='('){
                ++left;
            }else if(s.charAt(i)==')'){
                ++right;
            }else{
                return 0;
            }

            if(left==right){
                max = Math.max(max,left+right);
            }else if(left>right){		// 修改条件为左边多时
                left = 0;
                right = 0;
            }
        }

        return max;
    }
}
```

