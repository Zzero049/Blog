# 253、会议室2

给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

示例 1:

```
输入: [[0, 30],[5, 10],[15, 20]]
输出: 2
```

示例 2:

```
输入: [[7,10],[2,4]]
输出: 1
```



## 题解

单纯用贪心解不了，比如

```
[[0, 10],[3, 5],[6, 20],[12,33]]
```

输出为2，原因是[12,33]能用[0,10]的会议室



### 方法：排序+最小堆

由于后面的会议室可能会用到前面创建的会议室，不能只用贪心算法，这里再用一个小根堆去存每个会议室的结束时间，那么判断一场会议时：

- 如果该会议开始时间比堆顶（最小结束时间）的还早，那么说明需要另开一间会议室
- 如果该会议开始时间比堆顶（最小结束时间）的还晚，那么说明可以用这个堆顶的会议室

代码

```java
public class MinMeetingRooms {
    public int solution01(int[][] nums) {
        if (nums.length == 0 || nums[0].length == 0) {
            return 0;
        }
        Arrays.sort(nums, (o1, o2) -> o1[0] - o2[0]);
        PriorityQueue<Integer> pQueue = new PriorityQueue<>();		// 小根堆记录离会时间
        int rowLen = nums.length;
        pQueue.offer(nums[0][1]);
        for (int i = 1; i < rowLen; ++i) {
            if (nums[i][0] >= pQueue.peek()) {			// 当最早结束的会议室比自己开始时间早，那么可以用这个会议室
                pQueue.poll();							// 该时间出队，把自己进队
            }
            pQueue.offer(nums[i][1]);				// 进队，要么用别人的会议室（出队），要么自己另开
        }
        return pQueue.size();
    }
}
```

**复杂度分析**

时间复杂度：O(nlogn) 

空间复杂度：O(n)