# 21、合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```



## 题解

本题主要考察指针的转换关系，设定一个头节点可以在最后让我们比较容易地返回合并后的链表

### 方法：迭代

我们维护一个 p 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：

- 如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 p 节点的后面同时将 l1 指针往后移一位。
- 否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 p向后移一位。

在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

代码如下：

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null||l2==null){
            return l1==null?l2:l1;			// 其中一个为空，返回另一个即可
        }
        ListNode head = new ListNode(-1);	// 头结点
        ListNode p = head;
        while(l1!=null&&l2!=null){
            if(l1.val>l2.val){				// 每次取小的那个结点
                ListNode tmp = l2.next;		// 注意要保存下一个节点，否则调整指向关系后，就拿不到了
                p.next = l2;
                p = p.next;
                l2 = tmp;
            }else{
                ListNode tmp = l1.next;
                p.next = l1;
                p = p.next;
                l1 = tmp;
            }
        }
		// 其中一个链表的节点已经构造完了，剩下一个链表还没构造完
        if(l1!=null){
            p.next = l1;
        }
        if(l2!=null){
            p.next = l2;
        }

        return head.next;
    }
}
```

**复杂度分析**

时间复杂度：O（n+m），其中n和m分别为两个链表的长度。因为每次循环迭代中，l1和 l2只有个元素会被放进合并链表中，因此 while循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为O（n+m）

空间复杂度：O（1）。我们只需要常数的空间存放若干变量。