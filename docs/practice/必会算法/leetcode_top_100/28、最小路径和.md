# 64、最小路径和

给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```



## 题解

### 方法一：动态规划

和[27、不同路径](27、不同路径)相同，路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。

对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。

创建二维数组 dp，与原始网格的大小相同，`dp[i][j] `表示从左上角出发到`(i,j)`位置的最小路径和。显然，`dp[0][0]=grid[0][0]`。对于 dp 中的其余元素，通过以下状态转移方程计算元素值。

当 i>0 且 j=0 时，`dp[i][0] = dp[i-1][0] + grid[i][0]`。

当 i=0 且 j>0 时，`dp[0][j] = dp[0][j-1] + grid[0][j]`。

当 i>0 且 j>0  时，`dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + grid[i][j]`。

最后得到 `dp[m-1][n-1]`的值即为从网格左上角到网格右下角的最小路径和。

这里实际上还是只用了`dp[i-1][j]`和`dp[i][j-1]`可以降低空间复杂度，只使用一维数组`dp[m]`，其中`dp[j] `表示从左上角出发到`(i,j)`位置的最小路径和。

代码如下：

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int n = grid.length;
        int m = grid[0].length;
        int[] dp = new int[m + 1];
        for (int i = 0; i < m + 1; ++i) {				// 将所有元素都初始化为Integer.MAX_VALUE
            dp[i] = Integer.MAX_VALUE;					// 保证后续能取到最小
        }
        dp[1] = grid[0][0];								// 把第一个元素放进来
        
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (i == 0 && j == 0) {					// 不需要判断第一个元素
                    continue;
                }
                dp[j + 1] = Math.min(dp[j], dp[j + 1]) + grid[i][j];

            }
        }
        return dp[m];
    }
}
```

**复杂度分析**

时间复杂度：O(mn)，其中 m 和 n 分别是网格的列数和行数。需要对整个网格遍历一次，计算 dp 的每个元素的值。

空间复杂度：O(m)

