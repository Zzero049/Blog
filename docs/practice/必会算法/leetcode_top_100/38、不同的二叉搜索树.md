# 96、不同的二叉搜索树

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

示例:

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```



## 题解

### 方法一：数学法

事实上我们在方法一中推导出的 G(n))函数的值在数学上被称为[卡塔兰数](https://baike.baidu.com/item/catalan/7605685?fr=aladdin) C<sub>n</sub>。卡塔兰数便于计算的定义如下:

![image-20200909002351339](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200909002351339.png)

证明过程可以参考上述文献，此处不再赘述。

**王道书中给出的 `(2n)!/(n+1)!(n)!`，在计算过程很容易溢出，因此采取另一个计算方法，此处需要记忆**

```java
class Solution {
    public int numTrees(int n) {
        long ans = 1;

        for (int i = 0; i < n; ++i) {
            ans = ans * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) ans;
    }
}
```

复杂度分析

时间复杂度 : O(n)，其中 nn 表示二叉搜索树的节点个数。我们只需要循环遍历一次即可。
空间复杂度 : O(1)。我们只需要常数空间存放若干变量。

### 方法二：动态规划

假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则

```
G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)
```

当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则

```
f(i)=G(i−1)∗G(n−i)
```

综合两个公式可以得到 **卡特兰数** 公式

```
G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+...+G(n−1)∗G(0)
```

代码

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;						// 空节点算一种
        dp[1] = 1;						// 只有一个结点只有一种
        
        for(int i = 2; i <= n ; i++)			// i代表此时树的节点数目
            for(int j = 1; j <= i ; j++) 		// j代表此时树以j节点为根
                dp[i] += dp[j-1] * dp[i-j];		// 组合，乘法
        
        return dp[n];
    }
}
```

复杂度分析

时间复杂度 : O(n^2^)，其中 n 表示二叉搜索树的节点个数。一共有 n 个值需要求解，每次求解需要 O(n) 的时间复杂度，因此总时间复杂度为 O(n^2^)

空间复杂度 : O(n)。我们需要 O(n) 的空间存储 dp 数组。

