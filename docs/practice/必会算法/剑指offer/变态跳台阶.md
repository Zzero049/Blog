# 题目

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。(顺序不同，结果不同)

## 描述：

这是一道可以递归，记忆化递归，动态规划，递推思想的题目。

知识点：递归，动态规划，递推

难度：一星

## 题解：

### 方法一：暴力方法

设f[i] 表示 当前跳道第 i 个台阶的方法数。那么f[n]就是所求答案。

假设现在已经跳到了第 n 个台阶，那么前一步可以从哪些台阶到达呢？

如果上一步跳 1 步到达第 n 个台阶，说明上一步在第 n-1 个台阶。已知跳到第n-1个台阶的方法数为f[n-1]

如果上一步跳 2 步到达第 n 个台阶，说明上一步在第 n-2 个台阶。已知跳到第n-2个台阶的方法数为f[n-2]

。。。

如果上一步跳 n 步到达第 n 个台阶，说明上一步在第 0 个台阶。已知跳到 第0个台阶的方法数为f[0]，f[0]代表直接跳n阶

那么总的方法数就是所有可能的和。也就是f[n] = f[n-1] + f[n-2] + ... + f[0]

显然初始条件f[0] = f[1] = 1

所以我们就可以先求f[2]，然后f[3]...f[n-1]， 最后f[n]

#### 代码：

```
public int solution01(int target){
        int dp[] = new int[target+1];
        dp[0] = 1;
        dp[1] = 1;

        for(int i=2;i<=target;i++){
            dp[i] = 0;
            for(int j=i;j>=0;j--){
                dp[i] += dp[j];
            }
        }

        return dp[target];
    }
```

#### 复杂度分析：

#### 时间复杂度：O(n2)

**空间复杂度：O(n)**

### 方法二：继续优化

对于方法一中的：f[n] = f[n-1] + f[n-2] + ... + f[0]

那么f[n-1] 为多少呢？

f[n-1] = f[n-2] + f[n-3] + ... + f[0]

所以一合并，**f[n] = 2*f[n-1]**，初始条件f[0] = f[1] = 1

所以可以采用递归，记忆化递归，动态规划，递推。具体详细过程，可查看青蛙跳台阶。

这里直接贴出递推的代码。

#### 代码：

```
int jumpFloorII(int n) {
    if (n==0 || n==1) return 1;
    int a = 1, b;
    for (int i=2; i<=n; ++i) {
        b = a << 1; //  口诀：左移乘2，右移除2
        a = b;
    }
    return b;
}
```

当然，你会发现一个规律：

f[0] = f[1] = 1

f[2] = 2 = 2^1

f[3] = 4 = 2^2

f[4] = 8 = 2^3

...

**f[n] = 2^(n-1)**

所以，针对本题还可以写出更加简单的代码。

```
public class Solution {
    public int JumpFloorII(int target) {
        return 1<<(target-1);
        //return (int)Math.pow(2,target-1);
    }
}
```

#### 复杂度分析：

#### 时间复杂度：O(n)

**空间复杂度：O(1)**