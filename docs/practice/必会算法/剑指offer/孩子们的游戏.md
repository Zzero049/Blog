# 题目

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1

# 描述

这是一篇针对初学者的题解，共用三种方法解决。
知识点：数组，链表，递归
难度：二星

------

# 题解

题目抽象：给定一个由[0...n-1]构成的数组，第一次从0开始数m个数，然后删除，以后每次都从删除的数下一个位置开始数m个数，然后删除，直到剩余一个数字，找出那个数字。
比如：arr = [0 1 2 3 4]， m = 3
第一次：删除2 ，变成 arr = [0 1 3 4]
第二次，删除0，变成 arr = [1 3 4]
第三次，删除4，变成 arr = [1 3]
第四次，删除1，变成 arr = [3]

## 方法一：模拟

最开始长度为n，每次删除一个数，长度变为n-1，如果用数组模拟操作的话，删除一个数据，涉及大量的数据搬移操作，所以我们可以使用链表来模拟操作。
代码如下：

```java
	public int solution01(int n, int m) {
        if(n==0){
            return -1;
        }
        // 数组转换成链表，方便删除节点
        ListNode head = new ListNode(-1);
        ListNode p = head;
        for(int i=0;i<n;++i){
            ListNode node = new ListNode(i);
            p.next = node;
            p = p.next;
        }
        p.next = head.next;
        ListNode pre = head;
        p = head.next;
        int count = -1;
        while(p!=pre){          // 当最后只剩一个节点，退出循环
            count++;
            if(count==m-1){
                p = p.next;
                pre.next = p;
                count = -1;
            }else{
                pre = p;
                p = p.next;
            }
        }
        head = null;
        return p.val;
    }
```

时间复杂度：O(N^2), 每次删除一个节点，需要先找到那个节点，然后再删除，查找的时间复杂度为O(N)
空间复杂度：O(N)

## 方法二：递归

**1 约瑟夫问题**

这个问题实际上是约瑟夫问题，这个问题描述是

N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。

**2 问题转换**

既然约塞夫问题就是用人来举例的，那我们也给每个人一个编号（索引值），每个人用字母代替

下面这个例子是N=8 m=3的例子

我们定义F(n,m)表示最后剩下那个人的索引号，因此我们只关系最后剩下来这个人的索引号的变化情况即可

![约瑟夫环1.png](pictures/d7768194055df1c3d3f6b503468704606134231de62b4ea4b9bdeda7c58232f4-约瑟夫环1.png)

从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号

- 第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）
- 第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）
- 第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）

以此类推，当只剩一个人时，他的编号必定为0！（重点！）

**3 最终活着的人编号的反推**

现在我们知道了G的索引号的变化过程，那么我们反推一下

从N = 7 到N = 8 的过程

如何才能将N = 7 的排列变回到N = 8 呢？

我们先把被杀掉的C补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面

神奇了 经过这个操作就恢复了N = 8 的排列了！

![约瑟夫环2.png](https://gitee.com/zero049/MyNoteImages/raw/master/68509352d82d4a19678ed67a5bde338f86c7d0da730e3a69546f6fa61fb0063c-约瑟夫环2.png)

假设f(n, m) 表示最终留下元素的序号。比如上例子中表示为:f(5,3) = 3

长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。

由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 f(n, m) = (m % n + x) % n = (m + x) % n。

当n等于1时，f(1,m) = 0

例子：比如m=3，n=5；已知答案是剩余3

0 1 3 4  ---------------->第一次淘汰2，3为4个中的第2个（从0算），剩4个

1 3 4  ---------------->第二次淘汰0，3为3个中的第1个，剩3个

1 3   ---------------->第三次淘汰4，3为5个中的第1个，剩2个

3   ---------------->第三次淘汰1，3为5个中的第0个，剩1个

发现了吗？我们把最底层的递归出口设置为0（只有一个，下标就为0），要拿到上层的剩余节点的下标（不符合的原因是前面的被删掉，编号要重新计数），只需要加上m并取当前长度即可。

反推：

3   ---------------->直接返回0

1 3   ---------------->(3+0)%2==1

1 3  4 ---------------->(3+1)%3==1

0 1 3  4 ---------------->**(3+1)%4==0**，此处不符合，主要是因为最后通过+m还原到3

0 1 2 3  4---------------->(3+0)%5==3

剩的是3

代码为：

```java
	public int solution02(int n, int m){
        if(n<=0){
            return -1;
        }
        return f(n,m);
    }
    private int f(int n,int m){
        if(n==1){
            return 0;
        }

        int res = f(n-1,m);
        return (res+m)%n;
    }
```

时间复杂度：O(N)
空间复杂度: O(N)

## 方法三：迭代法

根据方法二可知，

f[1] = 0

f[2] = (f{1] + m) % 2

f[3] = (f[2] + m) % 3

...

f[n] = (f[n-1] + m) % n

所以代码如下：

```java
	public int solution03(int n, int m){
        if(n<=0){
            return -1;
        }
        int index = 0;
        for(int i=2;i<=n;++i){
            index = (index+m)%i;
        }
        return index;
    }
```

时间复杂度：O(N)
空间复杂度: O(1)