# 题目描述

给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**输入描述:**

```
输入一个数n，意义见题面。（2 <= n <= 60）
```

**输出描述:**

```
输出答案。
```

示例1

输入

```
8
```

输出 

```
18
```

分为2 3 3 



## 描述

这是一篇针对初学者的题解，从暴力递归到动态规划一步步讲解。
知识点：递归，动态规划
难度：二星

------

## 题解

题目描述：给定一个长度为n的绳子，将其分成m段（m>1）,求m段的乘积最大。
转化成数学上的描述：给定一个数n，求n = a1 + a2 ... +am, （m>1）在此条件下, s = a1 * a2 * ... * am， s最大

进入此题的讲解之前，先提出一个问题：什么样的题适合用动态规划？
针对本题来说，假如我们用暴力枚举的思路去思考，会出现以下一些问题：

1. 这段绳子到底应该分几段，才能得到最优的结果？
2. 假设我已经知道了要分m段（假设m已知），那么每段的长度又应该是多少呢？

可能你的问题不止上面2个。但是，仅仅是上面两个问题，已经让我感觉要分好多种情况，然后选出一个最优的。

当然，普通的for循环枚举所有情况是有难度的，但是幸运的是，我们可以用递归回溯。
所以，方法一如下：

### 方法一：暴力递归

暴力递归就要想到递归三部曲：

1. 递归函数的设计和功能：backtrack(n); 含义是：求长度为n的数，最后分段后的最大乘积，这里我们不需要关心分成多少段
2. 递归函数的终止条件: ==如果n <= 4, 可知backtrack(n) = n==，注意这里n是可以不分段的（递归已经进行了分段），而不分段1，2，3，4都取到了最大（4也可以由2+2组成，等价）
3. 下一步递归：对于长度n，我们需要减少递归参数n，如果第一段为1， 显然下一步递归为back_track(n-1),如果第一段为2， 则下一步递归为
   back_track(n-2)...因为要至少分2段，所以，最后一次可能的情况为最后一段为n-1, 下一步递归为back_track(1)，因此，每一步可能的结果为
   1 * back_track(n-1), 2 * back_track(n-2), ..., (n-1) * back_track(1),在n-1种情况中取一个最大值即可。 这里我们不用关系back_track(n-1)等的值为多少，因为最终会递归到我们的终止条件，因此绝对是可以求出来。

于是，有了上面三部曲，递归代码如下：

```java
public class Solution {
    public int cutRope(int target) {
        // target = 2 和 3 时，分 3 段和分 2 段的结果是不一样的，所以需要特判一下
        if (target == 2) {
            return 1;
        }
        else if (target == 3) {
            return 2;
        }
        return backtrack(target);
    }
    
    int backtrack(int n) {
        // n <= 4时, n不进行分段，长度是最大的
        if (n <= 4) {
            return n;
        }

        int ret = 0;
        for (int i = 1; i < n; ++i) { // i为本次分段取的长度，剩下长度为n-i继续计算下去
            ret = Math.max(ret, i * backtrack(n - i));
        }
        return ret;
    }
}
```

时间复杂度：O(n!)
空间复杂度：O(n), 最多分n段，每段长度为1， 所以递归深度为n

### 方法二：记忆化递归

根据方法一，假设求back_track(7)，如下图：
![image-20200829004709812](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200829004709812.png)

我用f() 替代 backtrack(),可知，红色的部分重复了。
因此，我们可以开一个数组，把计算过的结果存起来。
步骤如下：

- 初始化一个大小为 n+1 的数组，初始值为 -1 ， 也可以-2， 反正是不可能得到的值
- 在方法一的代码上，记录一下，各个长度的最大切片乘积即可，详细代码如下

代码如下：

```java
public class Solution {
    public int cutRope(int target) {
        // target = 2 和 3 时，分 3 段和分 2 段的结果是不一样的，所以需要特判一下
        if (target == 2) {
            return 1;
        }
        else if (target == 3) {
            return 2;
        }
        int[] mark = new int[target+1];		 // 用一个数组取记录计算结果，免去多次重复计算
        return backtrack(target,mark);
    }
    
    int backtrack(int n, int[] mark) {
        // n <= 4, 表明不分，长度是最大的
        if (n <= 4) {
            return n;
        }
        if(mark[n]!=0){
            return mark[n];
        }
        int ret = 0;
        for (int i = 1; i < n; ++i) {
            ret = Math.max(ret, i * backtrack(n - i, mark));
        }
        mark[n] = ret;			// 更新对应n
        return ret;
    }
}
```

时间复杂度：O(n^2)
空间复杂度：O(n)

### 方法三：动态规划

有的书上认为方法二是一种递归版本的动态规划。

所以，我们可以将方法二修改为迭代版本的动态规划。

代码如下：

```java
public class Solution {
    public int cutRope(int target) {
        // target = 2 和 3 时，分 3 段和分 2 段的结果是不一样的，所以需要特判一下
        if (target == 2) {
            return 1;
        } else if (target == 3) {
            return 2;
        }
        int[] mark = new int[target + 1];
        for (int i = 1; i <= 4; ++i) {
            mark[i] = i;
        }
        for (int i = 5; i <= target; ++i) {			// 剩余长度为5开始逐一计算出来，直到算出target位置下的结果
            for (int j = 1; j < i; ++j) {			// 尝试各种分段长，但是不能不分
                mark[i] = Math.max(mark[i], j * mark[i - j]);
            }
        }
        return mark[target];
    }
    
}
```

时间复杂度：O(n^2)
空间复杂度：O(n)

总的来说，方法一是基础。方法二，方法三都是在方法一的基础上修改的。

Q:接下来，我们就可以开篇的问题了，什么样的题适合用动态规划？
A：一般，动态规划有以下几种分类：

1. 最值型动态规划，比如求最大，最小值是多少
2. 计数型动态规划，比如换硬币，有多少种换法
3. 坐标型动态规划，比如在m*n矩阵求最值型，计数型，一般是二维矩阵
4. 区间型动态规划，比如在区间中求最值

其实，根据此题的启发，我们可以换种想法，就是什么样的题适合用暴力递归？
显然就是，可能的情况很多，需要枚举所有种情况。只不过动态规划，只记录子结构中最优的解。

### 方法四：数学证明

直觉上把数拆的越平均他们的积越大。拆分的整数越接近自然参数e，他们的乘积的越大。

数学证明：定义函数 f(x) 表示将给定的正整数 n 拆分成尽可能多的正数 x 的情况下的最大乘积，则可以将 n 分成x/n 项，此时 f(x)= x^n/x^，通过求导可得**f(x)在x=e时取最大值**，那么就是分成每段为2或者每段为3的时候取最大

```java
class Solution {
    public int cuttingRope(int n) {
        if(n==2){
            return 1;
        }else if(n==3){
            return 2;
        }

        int[] dp = new int[n+1];
        for(int i=1;i<=4;++i){
            dp[i] = i;
        }

        for(int i=5;i<=n;++i){
            dp[i] = 2*dp[i-2]>3*dp[i-3]?2*dp[i-2]:3*dp[i-3];
        }
        return dp[n];
    }
}
```

时间复杂度：O(n)

空间复杂度：O(1)



### 方法五：贪心算法

设一绳子长度为 n ( n>1 )，则其必可被切分为两段 n=n<sub>1</sub>+n<sub>2</sub>

根据经验推测，切分的两数字乘积往往原数字更大，即往往有n<sub>1</sub>*n<sub>2</sub> >n<sub>1</sub>+n<sub>2</sub>=n

**推论一：合理的切分方案可以带来更大的乘积。**

设一绳子长度为 n ( n>1 )，**切分为两段** n = n<sub>1</sub>+n<sub>2</sub> ，**切分成三段** n = n<sub>1</sub>+n<sub>2</sub> +n<sub>3</sub> 

根据经验推测，**三段** 的乘积往往更大，即往往有n<sub>1</sub> * n<sub>2</sub> * n<sub>3</sub> > n<sub>1</sub> * n<sub>2</sub>

- **例如绳子长度为 9**：两段9=4+5和三段9=3+3+3，则有4 * 5 < 3 * 3 * 3
- **也有少数反例，例如 6** 两段6 = 3 + 3和三段6=2+2+2，则有3 * 3 > 2 * 2 * 2

**推论二： 若切分方案合理，绳子段切分的越多，乘积越大。**

总体上看，貌似长绳子切分为越多段乘积越大，但其实到某个长度分界点后，乘积到达最大值，就不应再切分了。

**问题转化： 是否有优先级最高的长度 x 存在？**若有，则应该尽可能把绳子以 x 长度切为多段，以获取最大乘积。

**推论三： 为使乘积最大，只有长度为 2 和 3 的绳子不应再切分，且 3 比 2 更优 *（详情见下表）* 。**

| 绳子切分方案         | 乘积                    | 结论                                                      |
| -------------------- | ----------------------- | --------------------------------------------------------- |
| 2 = 1 + 1            | 1 * 1 = 1               | 2不应切分                                                 |
| 3 = 1 + 2            | 1 * 2 = 2               | 3不应切分                                                 |
| 4 = 2 + 2  = 1 +3    | 2 * 2 = 4 > 1*3=3       | 4和2等价，且2+2比1+3更优                                  |
| 5 = 2 + 3 = 1 + 4    | 2 * 3=6 >1 * 4=4        | 5应切分为2+3                                              |
| 6 = 3 + 3 = 2 + 2 +2 | 3 * 3 = 9 > 2 * 2 * 2=8 | 6应切分为3+3，进而推出3比2更优                            |
| />  7                | ...                     | 长绳（长度>7）可转化为多个短绳（长度1-6），因此肯定应切分 |



```java
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;		// 输入大于等于2
        int res=1;
        //贪心算法，优先切三，其次切二
        while(n>4){
            res=res*3;
            n-=3;
        }
        //出来循环只有三种情况，分别是n=2、3、4
        return res*n;
    }
}
```

