# 题目

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

------

## 题解

题目抽象：给定一个数组，数组中只有2个数字出现了一次，其余都出现了2次，找出这2个数字。

### 方法一：哈希法

很显然的方法，遍历一遍数组，用set记录只出现一次的数字（出现两次的删除），然后再遍历一遍set，找出出现1次的数字。

```java
	//num1,num2分别为长度为1的数组。传出参数
	//将num1[0],num2[0]设置为返回结果
	public void solution01(int[] array, int num1[], int num2[]) {
        if (array.length <= 1) {
            return;
        }

        HashSet<Integer> set = new HashSet<>();
        int len = array.length;
        for (int i = 0; i < len; i++) {
            // 出现过一次，则删除
            if (set.contains(array[i])) {
                set.remove(array[i]);
            } else {
                set.add(array[i]);
            }
        }

        Iterator<Integer> iterator = set.iterator();
        num1[0] = iterator.next();
        num2[0] = iterator.next();
    }
```

时间复杂度：O(n)
空间复杂度：O(n)

### 方法二：位运算

前提知识：
异或运算：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。

- n^0 = n;
- n^n = 0;
- n ^ n ^ m = n ^ (n ^ m) 满***换律

所以，我们可以让数组中的每一个数异或一下，**最后会得到一个结果ret，就是两个只出现一次的数字的异或结果**，这个结果肯定是由两个不同数字异或而来，因此我们**找ret二进制中为1的位置i，因为1一定是由0,1异或而来**，因此要求得两个数中，一定有一个数的二进制中的第i个位置为1， 一个为0.

依照这个思路，我们来看两个数（我们假设是A、B）出现一次的数组。我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是倒数第3位，接着把原数组分成两组，分组标准是倒数第3位是否为1。如此，出现过两次的数可能在任意一组，但是只出现过一次的数，一定不在同一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。

如何找到位置i？可用`i = ret & (-ret)`
因为计算机用补码存取二进制数，而负数的补码为反码+1，举个例子
假如`ret = 1110 ， -ret = 0010 , 所以 i = 0010`
所以，再异或一遍即可得到答案。

```java
	//num1,num2分别为长度为1的数组。传出参数
	//将num1[0],num2[0]设置为返回结果
	public void solution02(int[] array, int num1[], int num2[]) {
        if (array.length <= 1) {
            return;
        }

        int ret = 0;
        for (int k : array){
            ret ^= k;
        }
        ret &= (-ret);          // 找到 最低位为1
        num1[0] = 0;			// 先赋值为0，抑或为原数
        num2[0] = 0;
        for (int k : array) {
            if ((k & ret)!=0) {	// 该位，要么为0.要么为1，只出现一次的分开两组
                num1[0] ^= k;
            } else{
                num2[0] ^= k;
            }
        }
    }
```

时间复杂度：O(n)
空间复杂度：O(1)