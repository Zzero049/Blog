回文串（palindromic string）是指这个字符串无论从左读还是从右读，所读的顺序是一样的；简而言之，回文串是左右对称的。所谓最长回文子串问题，是指对于一个给定的母串

> abcdedcb

从所有的为回文串的子串a, ded, cdedc, bcdecdb中；找出最长的那一个bcdecdb。

### 又用了暴力解。。910ms，O^3
```java
public static String solution(String s){
        int i,j,k,l;
        int n = s.length();
        int maxLength=0;
        int maxIndex=0;
        int num=0;
        if(n<=1){
            return s;
        }
        for(i=0;i<n;i++){
            k=i;

            for(j=n-1;j>k;j--){
                num=0;
                l = j;
                while(s.charAt(k)==s.charAt(l)&&l>k){
                    if(l>k){
                        k++;
                        l--;
                        num+=2;
                        if(s.charAt(k)!=s.charAt(l))
                        {
                            num=0;
                            k=i;
                            break;
                        }
                        if(l==k){
                            num+=1;
                            break;
                        }
                    }
                }
                if(maxLength<num){
                    maxLength = Math.max(maxLength, num);
                    maxIndex = i;
                }


            }
        }
        if(maxLength==0){
            return s.substring(0,1);
        }

        return s.substring(maxIndex, maxIndex+maxLength);
    }
```


#### 翻转+动态规划法
<img src="./pictures/Annotation 2020-04-03 141141.png"  div align=center />


根据回文串的定义，正着和反着读一样，那我们是不是把原来的字符串倒置了，然后找最长的公共子串就可以了。例如 S = "caba" ，S = "abac"，最长公共子串是 "aba"，所以原字符串的最长回文串就是 "aba"。

关于求最长公共子串（不是公共子序列），有很多方法，这里用动态规划的方法，
整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话

arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。

当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。

arr [ i ][ j ] 保存的就是公共子串的长度。

再看一个例子，S="abc435cba"，S="abc534cba"，最长公共子串是 "abc" 和 "cba"，但很明显这两个字符串都不是回文串。

所以我们求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配。

比如 S="caba"，S'="abac" ，S’ 中 aba 的下标是 0 1 2 ，倒置前是 3 2 1，和 S 中 aba 的下标符合，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。

图实际上第0行0列为1
<img src="./pictures/Annotation 2020-04-03 142438.png"  div align=center />
首先 i，j 始终指向子串的末尾字符。所以 j 指向的红色的 a 倒置前的下标是 beforeRev = length-1-j=4-1-2=1，对应的是字符串首位的下标，我们还需要加上字符串的长度才是末尾字符的下标，也就是 beforeRev+arr\[i][j]-1=1+3-1=3，因为 arr\[i][j] 保存的就是当前子串的长度，也就是图中的数字 3。此时再和它与 i 比较，如果相等，则说明它是我们要找的回文串。

之前的 S="abc435cba"，S'="abc534cba"，可以看一下图示，为什么不符合。

<img src="./pictures/Annotation 2020-04-03 142515.png"  div align=center />

```java
public String longestPalindrome(String s) {
    if (s.equals(""))
        return "";
    String origin = s;
    String reverse = new StringBuffer(s).reverse().toString();
    int length = s.length();
    int[][] arr = new int[length][length];
    int maxLen = 0;
    int maxEnd = 0;
    for (int i = 0; i < length; i++)
        for (int j = 0; j < length; j++) {
            if (origin.charAt(i) == reverse.charAt(j)) {
                if (i == 0 || j == 0) {
                    arr[i][j] = 1;
                } else {
                    arr[i][j] = arr[i - 1][j - 1] + 1;
                }
            }
            /**********修改的地方*******************/
            if (arr[i][j] > maxLen) {
                int beforeRev = length - 1 - j;
                if (beforeRev + arr[i][j] - 1 == i) { //判断下标是否对应
                    maxLen = arr[i][j];
                    maxEnd = i;
                }
                /*************************************/
            }
        }
    return s.substring(maxEnd - maxLen + 1, maxEnd + 1);
}


```

时间复杂度O^2,空间复杂度 O^2，343ms

#### 暴力破解+动态规划

如果 S[i+1,j-1]S[i+1,j−1] 是回文串，那么只要 S[ i ]S[i] == $S[ j ] $，就可以确定 S[i,j]S[i,j]也是回文串了。

求 长度为 1 和长度为 2 的 P(i,j)P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j]中 i > j 的情况，比如求 P[1][2]P[1][2] 的话，我们需要知道 P[1+1][2-1]=P[2][1]P[1+1][2−1]=P[2][1] ，而 P[2][1]P[2][1] 代表着 S[2,1]S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。

所以我们先初始化长度是 11 的回文串的 P [ i , j ]P[i,j]，这样利用上边提出的公式 P(i,j)=(P(i+1,j-1)\&\&S[i]==S[j])P(i,j)=(P(i+1,j−1)&&S[i]==S[j])，然后两边向外各扩充一个字符，长度为 33 的，为 55 的，所有奇数长度的就都求出来了。

同理，初始化长度是 2 的回文串 P[i,i+1]，利用公式，长度为 4 的，6 的所有偶数长度的就都求出来了。


<img src="./pictures/Annotation 2020-04-03 150219.png"  div align=center />

```java
public String longestPalindrome(String s) {
    int length = s.length();
    boolean[][] P = new boolean[length][length];
    int maxLen = 0;
    String maxPal = "";
    for (int len = 1; len <= length; len++) //遍历所有的长度
        for (int start = 0; start < length; start++) {
            int end = start + len - 1;
            if (end >= length) //下标已经越界，结束本次循环
                break;
            P[start][end] = (len == 1 || len == 2 || P[start + 1][end - 1]) && s.charAt(start) == s.charAt(end); //长度为 1 和 2 的单独判断下
            if (P[start][end] && len > maxLen) {
                maxPal = s.substring(start, end + 1);
            }
        }
    return maxPal;
}


```

时间复杂度：两层循环 O(n²）

空间复杂度：用二维数组 PP 保存每个子串的情况 O(n²)O(n²)。

另一个版本,直接用循环变量i，j构造动态规划数组，外循环必须是从字符串末端开始
```java
public String longestPalindrome(String s) {
    int n = s.length();
    String res = "";
    boolean[][] dp = new boolean[n][n];
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i; j < n; j++) {
            dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1]); //j - i 代表长度减去 1        
            if (dp[i][j] &&  j - i + 1 > res.length()) {
                res = s.substring(i, j + 1);
            }
        }
    }
    return res;
}

```

### 扩展中心
我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。
<img src="./pictures/Annotation 2020-04-03 153125.png"  div align=center />

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);//奇数个
        int len2 = expandAroundCenter(s, i, i + 1);//偶数个
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}


```