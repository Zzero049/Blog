<img src="./pictures/Annotation 2020-04-06 165949.png
"  div align=center />

我用的排序+双指针法
```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int ans,result,preResult;
        if(nums.length<3){
            return 0;
        }
        quickSort(nums, 0, nums.length-1);
        ans = nums[0]+nums[1]+nums[2];
        int i=0;
        while(i<nums.length-2){
            int j=i+1;
            int k=nums.length-1;
            if((nums[i]>target&&target>0)||(target<0&&nums[i]>0)){
                return ans;
            }
            while(j<k){
                if(ans==target){
                    return target;
                }

                if(isNearZero(ans-target, nums[i]+nums[j]+nums[k]-target)){
                    ans = nums[i]+nums[j]+nums[k];
                }
                if(isNearZero(nums[i]+nums[j+1]+nums[k]-target,nums[i]+nums[j]+nums[k-1]-target)){
                    k--;
                    while(j<k && nums[k]==nums[k+1]) k--;

                }else{
                    j++;
                    while(j<k && nums[j]==nums[j-1]) j++;
                }


            }
            i++;
            while(i<nums.length-2 && nums[i]==nums[i-1]) i++;
        }
        return ans;
    }

    public boolean isNearZero(int ans,int judgeNum){
       if(judgeNum==0){
            return true;
        }
        if(ans>0&&judgeNum>0){
            if(ans<judgeNum){
                return false;
            }
            return true;
        }
        if(ans<0&&judgeNum<0){
            if(ans<judgeNum){
                return true;
            }
            return false;
        }
        if(ans>0&&judgeNum<0){
            if(ans<-judgeNum){
                return false;
            }
            return true;
        }
        if(ans<0&&judgeNum>0){
            if(-ans<judgeNum){
                return false;
            }
            return true;
        }
        return false;
    }

    public void quickSort(int[] nums, int start,int end){
        int i=start,j=end;
        int temp = nums[start];
        while(i<j){
            while(i<j&&nums[j]>temp) j--;
            if(i<j){
                nums[i] = nums[j];
                i++;
            }
            while(i<j&&nums[i]<=temp) i++;
            if(i<j){
                nums[j] = nums[i];
                j--;
            }
        }
        nums[i] = temp;
        if(start<i-1){
            quickSort(nums,start,i-1);
        }
        if(i+1<end){
            quickSort(nums,i+1,end);
        }

    }
}
```

有的方法是不需要自己写的
<img src="./pictures/Annotation 2020-04-06 170301.png
"  div align=center />

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[2];
        for(int i=0;i<nums.length;i++) {
            int start = i+1, end = nums.length - 1;
            while(start < end) {
                int sum = nums[start] + nums[end] + nums[i];
                if(Math.abs(target - sum) < Math.abs(target - ans))
                //用绝对值比较
                    ans = sum;
                if(sum > target)
                    end--;
                else if(sum < target)
                    start++;
                else
                    return ans;
            }
        }
        return ans;
    }
}

```