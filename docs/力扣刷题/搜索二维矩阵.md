<img src="pictures/Annotation 2020-04-16 161540.png">

缩小范围的暴力法也能做，但是不是高效的

```java
public boolean solution(int[][] matrix, int target) {
        int rowLen = matrix.length;
        int columnLen = matrix[0].length;
        if(rowLen==0) return false;
        for(int i=0;i<rowLen;i++){
            while(i<rowLen && matrix[i][columnLen-1]<target) i++;
            if(i>=rowLen) return false;
            for(int j=0;j<columnLen;j++){
                if(target==matrix[i][j]) return true;
                if(target<matrix[i][j]) return false;
            }
        }
        return false;
    }
```

## 二分查找
注意到输入的 m x n 矩阵可以视为长度为 m x n的有序数组。
<img src="pictures/Annotation 2020-04-16 161800.png">
由于该 虚 数组的序号可以由下式方便地转化为原矩阵中的行和列 (我们当然不会真的创建一个新数组) ，该有序数组非常适合二分查找。

```java
class Solution {
  public boolean searchMatrix(int[][] matrix, int target) {
    int rowLen = matrix.length;
        if(rowLen==0) return false;
        int columnLen = matrix[0].length;
        if(columnLen==0) return false;

        int start = 0,end = rowLen*columnLen-1;
        while(start<=end){
            int mid = (start+end)/2;
            int i = mid/columnLen;
            int j = mid%columnLen;
            if(matrix[i][j]==target) {
                return true;
            }else if(matrix[i][j]<target){
                start = mid+1;
            }else{
                end = mid - 1;
            }

        }

        return false;
  }
}
```