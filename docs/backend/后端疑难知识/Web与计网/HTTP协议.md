# HTTP协议

## HTTP请求报文

HTTP 请求分为三个部分：请求行、请求头、请求体。类似于下面这样：

![image-20200520182947818](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200520182947818.png)

### 1.1 请求方法

HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的

|      | 方法       | 作用                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 1    | **GET**    | **请求指定页面信息，并返回实体主体**                         |
| 2    | HEAD       | 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | **POST**   | **向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和或已有资源的修改。** |
| 4    | **PUT**    | **从客户端向服务器传送的数据取代指定的文档的内容。**也是**导致新的资源的建立和或已有资源的修改。** |
| 5    | PATCH      | 从客户端向服务器传送的数据取代指定的文档的内容。（部分取代） |
| 6    | **DELETE** | **请求服务器删除指定的页面。**                               |
| 7    | CONNECT    | HTTP11协议中预留给能够将连接改为管道方式的代理服务器         |
| 8    | OPTIONS    | 允许客户端查看服务器的性能。                                 |
| 9    | TRACE      | 回显服务器收到的请求，主要用于测试或诊断。                   |

HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：

- 一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定

- 另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。

本文所讨论的HTTP幂等性主要针对RESTful风格的，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是 RESTfu的Web AP设计都应该考虑幂等性。

### 1.2 URL

​	URL：统一资源定位符，是一种资源位置的抽象唯一识别方法。

   组成：<协议>://<主机>:<端口>/<路径>

   端口和路径有时可以省略（HTTP默认端口号是80，HTTPS默认端口号是443）

![image-20200520174925920](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200520174925920.png)

### 1.3 协议版本

协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1

### 2. 请求头部

 请求头部为请求报文添加了一些附加信息，由**“名/值”**对组成，每行一对，名和值之间使用冒号分隔。

 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据。

| 请求头          | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| Host            | 接受请求的服务器地址，可以是IP:端口号，也可以是域名          |
| User-Agent      | 发送请求的应用程序名称                                       |
| Connection      | 指定与连接相关的属性，如 Connection:Keep-Alive               |
| Accept-Charset  | 通知服务端可以发送的编码格式                                 |
| Accept-Encoding | 通知服务端可以发送的数据压缩格式                             |
| Accept-Language | 通知服务端可以发送的语言                                     |
| Content-Length  | 请求体长度                                                   |
| Content-Type    | 表示请求体中的MIME类型（Internet Media Type，互联网媒体类型）信息。 |

**Content-Type内容**:

常见的媒体格式类型如下：

-   text/html ： HTML格式
-   text/plain ：纯文本格式   
-   text/xml ： XML格式
-   image/gif ：gif图片格式  
-   image/jpeg ：jpg图片格式 
-   image/png：png图片格式

  以application开头的媒体格式类型：

-   application/xhtml+xml ：XHTML格式
-   application/xml   ： XML数据格式
-   application/atom+xml ：Atom XML聚合格式  
-   application/json  ： JSON数据格式
-   application/pdf    ：pdf格式 
-   application/msword ： Word文档格式
-   application/octet-stream ： 二进制流数据（如常见的文件下载）
-   application/x-www-form-urlencoded ： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

  另外一种常见的媒体格式是上传文件之时使用的：

-   multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

   以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。

### 3. 请求数据

请求数据不在GET方法中使用，而在POST方法中使用。POST法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头部是 Content-Type和 Content-Length。下面是一个POST方法的请求报文

```
POST 　/index.php　HTTP/1.1 　　 //请求行

Host: localhost

User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　 //请求头

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8

Accept-Language: zh-cn,zh;q=0.5

Accept-Encoding: gzip, deflate

Connection: keep-alive

Referer: http://localhost/

Content-Length：25

Content-Type：application/x-www-form-urlencoded

```



## HTTP响应报文

HTTP 响应分为三个部分：状态行、响应头、响应正文。类似于下面这样：

![image-20200520183038292](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200520183038292.png)

### 1. 状态码

| **类别** | **原因短语**                                           |
| -------- | ------------------------------------------------------ |
| 1XX      | Informational（信息性状态码） 接受的请求正在处理       |
| 2XX      | Success（成功状态码） 请求正常处理完毕                 |
| 3XX      | Redirection（重定向状态码） 需要进行附加操作以完成请求 |
| 4XX      | Client Error（客户端错误状态码） 服务器无法处理请求    |
| 5XX      | Server Error（服务器错误状态码） 服务器处理请求出错    |

#### 常见状态码

**1XX**

| 状态码和状态信息 | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| 100 continue     | 服务器收到了客户端的请求行和头部信息，告诉客户端继续发送数据部分。客户端通常要先发送Expect：100-continue头部字段告诉服务器自己还有数据要发送 |



**2XX**

| 状态码和状态信息    | 含义                                       |
| ------------------- | ------------------------------------------ |
| 200 OK              | 表示从客户端发来的请求在服务器端被正确处理 |
| 204 No content      | 表示请求成功，但响应报文不含实体的主体部分 |
| 206 Partial Content | 进行范围请求成功                           |



**3XX**

| 状态码和状态信息       | 含义                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 301 moved permanently  | 永久性重定向，表示资源已被分配了新的 URL                     |
| 302 found              | 临时性重定向，表示资源临时被分配了新的 URL                   |
| 303 see other          | 表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求） |
| 304 not modified       | 表示服务器允许访问资源，但请求未满足条件的情况（从服务器告诉客户端，本地缓存的资源和我现在最新的资源是一致的，本地缓存拿出对应资源即可） |
| 307 temporary redirect | 临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 |



**4XX**

| 状态码和状态信息 | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| 400 bad request  | 请求报文存在语法错误                                         |
| 401 unauthorized | 表示发送的请求需要有通过 HTTP 认证的认证信息                 |
| 403 forbidden    | 表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述(认证之后权限不足) |
| 404 not found    | 表示在服务器上没有找到请求的资源                             |



**5XX**

| 状态码和状态信息         | 含义                                                 |
| ------------------------ | ---------------------------------------------------- |
| 500 internal sever error | 表示服务器端在执行请求时发生了错误                   |
| 501 Not Implemented      | 表示服务器不支持当前请求所需要的某个功能             |
| 503 service unavailable  | 表明服务器暂时处于超负载或正在停机维护，无法处理请求 |



### 2. 响应头部

![image-20200520185114743](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200520185114743.png)



### 3. 响应数据

​    用于存放需要返回给客户端的数据信息。



示例：

```
HTTP/1.1 200 OK　　状态行

Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部

Server: Apache/2.2.8 (Win32) PHP/5.2.5

X-Powered-By: PHP/5.2.5

Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/

Expires: Thu, 19 Nov 1981 08:52:00 GMT

Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0

Pragma: no-cache

Content-Length: 4393

Keep-Alive: timeout=5, max=100

Connection: Keep-Alive

Content-Type: text/html; charset=utf-8

　　空行

 

<html>　　响应数据

<head>

<title>HTTP响应示例<title>

</head>

<body>

Hello HTTP!

</body>

</html>

```





## HTTP中的幂等性

**幂等（idempotence）**是个数学与计算机学概念，常见于抽象代数中。
在编程中，一个幂等操作的特点是其**任意多次执行**所产生的影响均**与一次执行的影响相同**。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。

例如，“getUsername()和 setTrue()”函数就是一个幂等函数，只要我们不改变资源内容，得到的都是同样的结果

更复杂的操作幂等保证是利用**唯一交易号（流水号）**实现



 从定义上看，**HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用**。说白了就是，**同一个请求，发送一次和发送N次效果是一样的。**

### 案例

常见的一个幂等性的案例就是从银行账户中取钱：

```
withdraw(account id，amount)
```

如果扣除成功返回true，账户余额减少 amount；如果扣除失败则返回 false，账户余额不变。

值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。

一种典型的情况是 withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了(丢包)，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了 withdraw被调用两次，账户也被多扣了一次钱。

![image-20200520161523533](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200520161523533.png)

1. 解决方案一是采用**分布式事务**，通过引入支持分布式事务的**中间件**来保证 withdraw功能的事务性。
   - 分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。
   - 缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。
2. 另一种更轻量级的解决方案是**幂等设计**。我们可以通过一些技巧把 withdraw变成幂等的，比如

```
int create_ticket() 	//获取一个服务器端生成的唯一的处理号 ticket id
bool idempotent_withdraw(ticket_id, account id, amount)
```

create_ticket的语义是获取一个服务器端生成的唯一的处理号 ticket_id，它将用于标识后续的操作。idempotent withdraw和 withdraw的区别在于关联了个 ticket_id，**一个 ticketid表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果**。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用

**Head**是**幂等**的

**Get方法**用于获取资源，不应有副作用，所以是**幂等**的（幂等性指的是作用于结果而非资源本身，get每次都获取的是同一个资源的结果）

**Delete方法**用于删除资源，有副作用，调用一次和多次对资源产生影响是相同的，它应该满足**幂等**性

**POST**所对应的URI并非创建的资源本身，而是资源的接收者。比如：

POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，**POST方法不具备幂等性**

**PUT**所对应的URI是要创建或更新的资源本身，他直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的HTTP方法，所以**满足幂等性**。比如：

PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性

**Patch**方法只是更新部分资源，PATCH提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。换句话说，PATCH请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是**非幂等**的了



## 请求方法的区别

### GET与POST区别

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中（也可以藏在request body里，取决于服务器处不处理）；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。

2. Get请求提交的url中的数据通常最多只能是2KB，这个限制是浏览器或者服务器给添加的（大多数浏览器最多处理64KB的url），http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。

3. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

4. GET请求会被浏览器主动cache缓存，而POST不会，除非手动设置。

5. GET产生一个TCP数据包；POST产生两个TCP数据包。因此GET会比POST更高效一些。（一次请求，分两个包数据包发送）

   对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

   而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响

   应200 ok（返回数据）。

6. GET是幂等的，POST不是幂等的

### POST与PUT区别

POST方法和PUT方法都可以对一个资源进行创建或者修改，根本区别在于POST方法不是幂等的，而PUT方法满足幂等性。





## HTTP各版本区别

### HTTP 1.0——短连接

HTTP 协议老的标准是HTTP/1.0，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，**浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，**服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，**一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址**，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的图像标签后，浏览器将根据标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求。显然，**访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接**，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。当一个网页文件中包含JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。

同时，带宽和延迟也是影响一个网络请求的重要因素。在网络基础建设已经使得带宽得到极大的提升的当下，大部分时候都是延迟在于响应速度。基于此会发现，http1.0被抱怨最多的就是**连接无法复用**，和**head of line blocking**这两个问题。理解这两个问题有一个十分重要的前提：客户端是依据域名来向服务器建立连接，一般PC端浏览器会针对单个域名的server同时建立6～8个连接，手机端的连接数则一般控制在4～6个。显然连接数并不是越多越好，资源开销和整体延迟都会随之增大。连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞。

head of line blocking(holb)会导致健康的请求会被不健康的请求影响，而且这种体验的损耗受网络环境影响，出现随机且难以监控。为了解决holb带来的延迟，协议设计者设计了一种新的pipelining机制。pipelining只能适用于http1.1,而且由于使用苛刻，很多浏览器厂商并不支持。

### HTTP1.1——支持长连接

为了克服HTTP 1.0的这个缺陷，**HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应**，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。

在http1.1中，client和server都是默认对方支持长链接的， **如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close**；**如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close**。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。

HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。HTTP 1.1通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。如，HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP/1.0不支持文件断点续传，<code>RANGE:bytes</code>是HTTP/1.1新增内容，HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。<code>RANGE:bytes=XXXX</code>表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传！

**由上，HTTP/1.1相较于 HTTP/1.0 协议的区别主要体现在：**

（1）**默认持久连接节省通信量，**只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，**一次tcp连接可以发送多次HTTP请求**

（2）管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应

（3）断点续传，实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。

**移动app上的困难**

一段时间内的连接复用对PC端浏览器的体验帮助很大，因为大部分的请求在集中在一小段时间以内。但对移动app来说，成效不大，app端的请求比较分散且时间跨度相对较大。所以移动端app一般会从应用层寻求其它解决方案，长连接方案或者伪长连接方案：

方案一：基于tcp的长链接

现在越来越多的移动端app都会建立一条自己的长链接通道，通道的实现是基于tcp协议。基于tcp的socket编程技术难度相对复杂很多，而且需要自己制定协议，但带来的回报也很大。信息的上报和推送变得更及时，在请求量爆发的时间点还能减轻服务器压力（http短连接模式会频繁的创建和销毁连接）。不止是IM app有这样的通道，像淘宝这类电商类app都有自己的专属长连接通道了。现在业界也有不少成熟的方案可供选择了，google的protobuf就是其中之一。

方案二：http long-polling（推送）

客户端在初始状态就会发送一个polling（轮寻）请求到服务器，服务器并不会马上返回业务数据，而是等待有新的业务数据产生的时候再返回。所以连接会一直被保持，一旦结束马上又会发起一个新的polling请求，如此反复，所以一直会有一个连接被保持。服务器有新的内容产生的时候，并不需要等待客户端建立一个新的连接。做法虽然简单，但有些难题需要攻克才能实现稳定可靠的业务框架：
 和传统的http短链接相比，长连接会在用户增长的时候极大的增加服务器压力，
 移动端网络环境复杂，像wifi和4g的网络切换，进电梯导致网络临时断掉等，这些场景都需要考虑怎么重建健康的连接通道。这种polling的方式稳定性并不好，需要做好数据可靠性的保证，比如重发和ack机制（ACK是一个对数据包的确认，当正确收到数据包后，接收端会发送一个ACk给发送端，里面会说明对那个数据包进行确认，每个数据包里都会有一个序列号，如果收到的数据包有误，或错序，还会申请重发，NAK是一个否定的回答，ACK是确定回答，这样保证数据的正确传输）。

polling的response有可能会被中间代理cache住，要处理好业务数据的过期机制。long-polling方式还有一些缺点是无法克服的，比如每次新的请求都会带上重复的header信息，还有数据通道是单向的，主动权掌握在server这边，客户端有新的业务请求的时候无法及时传送。

方案三：http streaming

同long-polling不同的是，server并不会结束初始的streaming请求，而是持续的通过这个通道返回最新的业务数据。显然这个数据通道也是单向的。streaming是通过在server response的头部里增加”Transfer Encoding: chunked”来告诉客户端后续还会有新的数据到来。除了和long－polling相同的难点之外，streaming还有几个缺陷：有些代理服务器会等待服务器的response结束之后才会将结果推送到请求客户端。对于streaming这种永远不会结束的方式来说，客户端就会一直处于等待response的过程中。业务数据无法按照请求来做分割，所以客户端每收到一块数据都需要自己做协议解析，也就是说要做自己的协议定制。streaming不会产生重复的header数据。

方案四：web socket

WebSocket和传统的tcp socket连接相似，也是基于tcp协议，提供双向的数据通道。WebSocket优势在于提供了message的概念，比基于字节流的tcp socket使用更简单，同时又提供了传统的http所缺少的长连接功能。不过WebSocket相对较新，2010年才起草，并不是所有的浏览器都提供了支持。各大浏览器厂商最新的版本都提供了支持。



### HTTP2.0——支持多路复用

使用[HTTP2.0测试](https://http2.akamai.com/demo)便可看出HTTP2.0比之前的协议在性能上有很大的提升。下面总结了HTTP2.0协议的几个特性。

**多路复用 (Multiplexing)**

多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。

**二进制分帧**

HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。

HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。

**首部压缩（Header Compression）**

HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。

**服务端推送（Server Push）**

服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。



**现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？**

在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，

持久连接：既然维持 TCP 连接好处这么多**，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，**除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。

所以第一个问题的答案是：**默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接**。

**第二个问题**

**一个 TCP 连接可以对应几个 HTTP 请求？**

了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送**多个** HTTP 请求的。

**第三个问题**

**一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？**

HTTP/1.1 存在一个问题**，单个 TCP 连接在同一时刻只能处理一个请求（串行处理）**，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。

虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。

先来看一下 Pipelining 是什么，RFC 2616 中规定了：

A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received. 一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。

Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：

​    一些代理服务器不能正确的处理 HTTP Pipelining。

  正确的流水线实现是复杂的。

 Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。

所以现代浏览器默认是不开启 HTTP Pipelining 的。

但是，HTTP2 提供了 **Multiplexing 多路传输特性（多路复用），可以在一个 TCP 连接中同时完成多个 HTTP 请求**。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。

 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 **HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。**

那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

1. ​    维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
2.    和服务器建立多个 TCP 连接。

**第四个问题**

**为什么有的时候刷新页面不需要重新建立 SSL 连接？**

在第一个问题的讨论中已经有答案了，**TCP 连接有的时候会被浏览器和服务端维持一段时间。****TCP 不需要重新建立，SSL 自然也会用之前的。**

**第五个问题**

**浏览器对同一 Host 建立 TCP 连接到数量有没有限制？**

假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。

所以答案是：有。**Chrome 最多允许对同一个 Host 建立****六个** **TCP 连接。不同的浏览器有一些区别。**

那么回到最开始的问题，**收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？**

如果图片都是 **HTTPS 连接并且在同一个域名下**，那么**浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2**，如果能的话就使用 Multiplexing 功能在这个连接上进行**多路传输**。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。