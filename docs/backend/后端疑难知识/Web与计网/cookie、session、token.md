# 会话跟踪技术

HTTP是无状态协议，是指协议对于交互性场景没有记忆能力，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。**这就意味着服务器无法从连接上跟踪会话**。但是一些场景又需要保存信息（比如用户信息），这里就衍生出来了cookie、session、token

## cookie

Http cookie（也叫 Web Cookie或浏览器 Cookie）是**服务器发送到用户浏览器以KV形式井保存在本地（可以在内存、也可以持久化在磁盘里）的文本数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上**。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。

由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。所以每个域的cookie数量是有限制的。

### 作用

Cookie主要用于以下三个方面：

- **会话状态管理**（如用户登录状态、购物车、视频从上次离开位置播放、游戏分数或其它需要记录的信息）
- **个性化设置**（如用户自定义设置、主题等）
- **浏览器行为跟踪**（如跟踪分析用户行为等）

Cookie曾一度用于客户端数据的，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定 Cookie后，浏览器的每次请求都会携带 Cookie会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或IndexedDB。

### 设置

**客户端设置**

```js
document.cookie = "name=xiaoming; age=12 "
```

- 客户端可以设置cookie的一下选项: expires, domain, path, secure(只有在https协议的网页中, 客户端设置secure类型cookie才能生效), 但无法设置httpOnly选项

> 设置cookie => cookie被自动添加到request header中 => 服务端接收到cookie

**服务端设置**

不管你是请求一个资源文件(如html/js/css/图片), 还是发送一个ajax请求, 服务端都会返回response.而response header中有一项叫`set-cookie`, 是服务端专门用来设置cookie的;

- 一个set-cookie只能设置一个cookie, 当你想设置多个, 需要添加同样多的`set-cookie`
- 服务端可以设置cookie的所有选项: expires, domain, path, secure, HttpOnly



当服务器收到HTTP请求时，服务器可以在响应首部里面添加一个Set-Cookie选项，浏览器收到响感后通常会保存下 Cookie，之后对该服务器毎一次请求中都通过 Cookie请求首部将 Cookie信息发送服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

服务器使用set-Cookie响应首部向用户代理（一般是浏览器）发送 Cookie信息，告知客户端保存Cookie信息。一个简单的 Cookie可能像这样：Set-Cookie：<cookie名>=<cookie值>

![image-20200920164258647](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200920164258647.png)



### 类型

**会话期 Cookie**

会话期 Cookie是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie也会被保留下来，就好像浏览器从来没有关闭一样。

**持久性 Cookie**

和关闭浏览器便失效的会话期 Cookie不同，持久性 Cookie可以指定一个特定的过期时间（Expires或有效期（Max-Age）

提示：当 Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端

**第三方 Cookie**

每个 Cookie都会有与之关联的域（Domain），如果 Cookie的域和页面的域相同，那么我们称这个Cookie为第一方 Cookie（first-party cookie），如果 Cookie的域和页面的域不同，则称之为第三方Cookie（third-party cookie.）。一个页面包含图片或存放在其他域上的资源（如图片广告）时，第一方的 Cookie也只会发送绐设置它们的服务器。通过第三方组件发送的第三方 Cookie主要用于广告和网络追踪。这方面可以看谷歌使用的 Cookie类型（types of cookies used by Google）。大多数浏览器默认都允许第三方 Cookie，但是可以通过附加组件来阻止第三方 Cookie（如EF的 Privacy Badger）



## sesssion

session从字面上讲，就是会话。这个就类似你和一个人交谈，你怎么知道当时和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他是张三；

 session也是类似的道理，**服务器要知道当前请求发给自己的是谁。为了做这种区分，服务器就是要给每个客户端分配不同的"身份标识"，然后客户端每次向服务器发请求的时候，都带上这个”身份标识“**，服务器就知道这个请求来自与谁了。

至于客户端怎么保存这个”身份标识“，可以有很多方式，对于浏览器客户端，大家都采用cookie的方式。

![img](https://gitee.com/zero049/MyNoteImages/raw/master/3297464-7eff2f6a4fbdea7e.png)

过程如下：

1. 用户向服务器发送用户名和密码

2. 服务器验证通过后,在当前对话(session)里面保存相关数据,比如用户角色, 登陆时间等;

3. 服务器向用户返回一个`session_id`, 写入用户的`cookie`

4. **用户随后的每一次请求，自动判断此域名下是否存在 `cookie` 信息, 如果存在都会通过`cookie`, 将`session_id`传回服务器**

5. 服务端收到 `session_id`, 找到前期保存的数据, 由此得知用户的身份

### 扩展性

单机当然没问题， **如果是服务器集群， 或者是跨域的服务导向架构， 这就要求session数据共享，每台服务器都能够读取session**。

举例来说， A网站和B网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？这个问题就是如何实现单点登录的问题

1. Nginx ip_hash 策略，服务端使用 Nginx 代理，**每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器**，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。

2. Session复制：**任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。**

   ![img](https://gitee.com/zero049/MyNoteImages/raw/master/3297464-2f9ea6bc45374284.png)

   

3. 共享Session：**将Session Id 集中存储到一个地方**，所有的机器都来访问这个地方的数据，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败；

   ![img](https://gitee.com/zero049/MyNoteImages/raw/master/3297464-254c19c32109c777.png)

另一种方案是服务器索性不保存session数据了，所有数据就保存在客户端，每次请求都发回服务器。这种方案就是接下来要介绍的基于Token的验证;



## Token

![img](https://gitee.com/zero049/MyNoteImages/raw/master/3297464-877332de2216179a.png)

1. 用户通过用户名和密码发送请求
2. 程序验证
3. 程序返回一个token签名给客户端
4. 客户端储存token, 并且每次用户发送请求的时候带上token
5. 服务端验证Token并返回数据

这个方式的技术其实很早就已经有很多实现了，而且还有现成的标准可用，这个标准就是JWT;



## cookie和session区别

Cookie 和 Session 有什么不同？

- 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。
- 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- session会在一定时间内保存在服务器上。当访问增多，就会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。




## token和session区别

Session是一种HTTP储存机制， 为无状态的HTTP提供持久机制;

Token就是令牌， 比如你授权(登录)一个程序时，它就是个依据，判断你是否已经授权该软件；

Session和Token并不矛盾，作为身份认证**Token安全性比Session好**，因为每一个请求都有签名还能防止监听以及重放攻击，而Session就必须依赖链路层来保障通讯安全了。如上所说，如果你需要实现有状态的回话，仍然可以增加Session来在服务端保存一些状态。

下面的例子可以说明token和session的区别

session ：我发给你一张身份证，但只是一张写着身份证号码的纸片。你每次来办事，我去后台查一下你的 id 是不是有效。 

token：我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。 



- session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；
- session存储在服务器端，token存储在客户端（和cookie一样，服务器返回给客户端）
- token提供认证和授权功能，作为身份认证，token安全性比session好；
- session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下  

CSRF跨站伪造请求攻击：某用户登录了A网站，认证信息保存在cookie中。当用户访问攻击者创建的B网站时，攻击者通过在B网站发送一个伪造的请求提交到A网站服务器上，让A网站服务器误以为请求来自于自己的网站，于是执行响应的操作，该用户的信息边遭到了篡改。总结起来就是，攻击者利用用户在浏览器中保存的认证信息，向对应的站点发送伪造请求。用户的认证是通过保存在cookie中的数据实现，在发送请求是，只要浏览器中保存了对应的cookie，服务器端就会认为用户已经处于登录状态，而攻击者正是利用了这一机制。