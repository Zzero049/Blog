## DDOS攻击

DDoS（分布式拒绝服务）：这个的攻击借助于客户/服务器技术，将多个计算机联合起来作为一个攻击平台，对一个或者是多个目标发动攻击，从而成倍的提高就裁决服务攻击的威力。

这里介绍常见的SYN攻击。

### SYN泛洪攻击



![](https://gitee.com/zero049/MyNoteImages/raw/master/20200920105321.png)

SYN泛洪攻击原理如下：

攻击者**首先伪造地址对服务器发起SYN请求**（我可以建立连接吗？），服务器就会回应一个ACK+SYN（可以+请确认）。而**真实的IP会认为，我没有发送请求**，不作回应。服务器没有收到回应，会重试3-5次并且等待一个SYN Time（一般30秒-2分钟）后，丢弃这个连接。

如果攻击者大量发送这种伪造源地址的SYN请求，服务器端将会消耗非常多的资源来处理这种**半连接**，保存遍历会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行**SYN+ACK的重试**。TCP是可靠协议，这时就会**重传报文**，默认重试次数为5次，重试的间隔时间从1s开始每次都番倍，分别为1s + 2s + 4s + 8s +16s = 31s,第5次发出后还要等32s才知道第5次也超时了，所以一共是31 + 32 = 63s。

也就是说一共假的syn报文，会占用TCP准备队列63s之久，而**半连接队列默认为1024**，系统默认不同，可查看

```
cat /proc/sys/net/ipv4/tcp_max_syn_backlog c
```

也就是说在没有任何防护的情况下，每秒发送200个伪造syn包，就足够**撑爆半连接队列，从而使真正的连接无法建立，无法响应正常请求。** 最后的结果是服务器无暇理睬正常的连接请求—拒绝服务。



**Syn_Flood防御**

**cookie源认证：** 

原理是syn报文首先**由DDOS防护系统来响应syn_ack**。带上特定的sequence number （记为cookie）。真实的客户端会返回一个ack 并且Acknowledgment number 为cookie+1。 而伪造的客户端，将不会作出响应。这样我们就可以知道那些IP对应的客户端是真实的，将真实客户端IP加入白名单。下次访问直接通过，而其他伪造的syn报文就被拦截。下面为防护示意图： 

![image-20200920111315005](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200920111315005.png)

**reset认证：** 

Reset认证利用的是TCP协议的可靠性，也是**首先由DDOS防护系统来响应syn**。防护设备收到syn后响应syn_ack,将Acknowledgement number (确认号)设为特定值（记为cookie）。当**真实客户端收到这个报文时，发现确认号不正确，将发送reset报文**，并且sequence number 为cookie + 1。 而伪造的源，将不会有任何回应。这样我们就可以将真实的客户端IP加入白名单。 

![image-20200920111621385](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200920111621385.png)

**TCP首包丢弃:**

该算法利用了TCP/IP协议的重传特性，来自某个源IP的**第一个syn包到达时被直接丢弃并记录状态(五元组)，在该源IP的第2个syn包到达时进行验证，然后放行。**

当防御设备接到一个IP地址的SYN报文后:

1. 接受到syn报文   -> 简单比对该IP是否存在于白名单中:  存在则转发到后端，否则进行第2步
2. 不存在于白名单中 -> 检查是否是该IP在一定时间段内的首次SYN报文： 不是则进行第3步，是则进行第5步
3. 不是首次SYN报文 -> 检查是否重传报文： 是重传则转发并加入白名单，不是则丢弃并加入黑名单
4. 是首次SYN报文  -> 丢弃并等待一段时间以试图接受该IP的SYN重传报文，等待超时则判定为攻击报文加入黑名单。 

首包丢弃方案对用户体验会略有影响，因为丢弃首包重传会增大业务的响应时间，有鉴于此发展出了一种更优的TCP Proxy方案。所有的SYN数据报文由清洗设备接受，按照SYN Cookie方案处理。和设备成功建立了TCP三次握手的IP地址被判定为合法用户加入白名单，由设备伪装真实客户端IP地址再与真实服务器完成三次握手，随后转发数据。而指定时间内没有和设备完成三次握手的IP地址，被判定为恶意IP地址屏蔽一定时间。除了SYN Cookie结合TCP Proxy外，清洗设备还具备多种畸形TCP标志位数据包探测的能力，通过对SYN报文返回非预期应答测试客户端反应的方式来鉴别正常访问和恶意行为。



### CC攻击

CC攻击即ChallengeCollapsar挑战黑洞，主要通过大量的肉鸡或者寻找匿名代理服务器，模拟真实的用户向目标发起大量的访问请求，导致消耗掉大量的并发资源，使网站打开速度慢或拒绝服务。现阶段CC攻击是应用层攻击方式之一。





## XSS攻击

**XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。**XSS的重点不在于跨站点，而在于脚本的执行。

那么XSS的原理是：

恶意攻击者**在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行**，因此会达到恶意攻击用户的目的。那么XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。

关于XSS有关危害，我这里中罗列一段列表，详细介绍不进行更多的赘述：

- 挂马
- 盗取用户Cookie。
- DOS（拒绝服务）客户端浏览器。
- 钓鱼攻击，高级的钓鱼技巧。
- 删除目标文章、恶意篡改数据、嫁祸。
- 劫持用户Web行为，甚至进一步渗透内网。
- 爆发Web2.0蠕虫。
- 蠕虫式的DDoS攻击。
- 蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据

**反射型xss**

发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。

**存储型XSS**

存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码

最典型的例子是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示，浏览器发现有XSS代码，就当做正常的HTML与Js解析执行，于是触发了XSS攻击。

**DOM XSS**

DOM XSS和反射型XSS、存储型XSS的差别在于DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。



## sql注入

SQL注入是通过客户端的输入把SQL命令注入到一个应用的数据库中，从而执行恶意的SQL语句。

什么意思呢？我们来打个比方：我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 `or '123' = '123` 这样的。

我们在查询用户名和密码是否正确的时候，本来执行的sql语句是：`select * from user where username = '' and password = ''`. 这样的sql语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的sql语句就是：

`select * from user where username = '' and password = ' ' or '123' = '123 '; `这样的了，那么会有一个or语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：'; drop table user;, 这样的话，那么sql命令就变成了：

**`select * from user where username = '' and password = ''; drop table user;'`** , 那么这个时候我们会把user表直接删除了。

sql被攻击的原因是：sql语句伪造参数，然后对参数进行拼接后形成xss攻击的sql语句。最后会导致数据库被攻击了。

**防范的方法：**

1. 我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用。
2. 数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的方式