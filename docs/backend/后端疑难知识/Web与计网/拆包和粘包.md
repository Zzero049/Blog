# TCP 粘包拆包（消息边界问题）

## TCP无边界保护

我们都知道，**TCP协议是面向流的**。面向流是指**无保护消息边界**的，如果发送端连续发送数据，接收端有可能在一次接收动作中会接收两个或者更多的数据包。

那什么是保护消息边界呢？就是指传输协议**把数据当做一条独立的消息在网上传输，接收端只能接收独立的消息。**也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。

举个例子来说，连续发送**三个数据包，大小分别是1k，2k，4k**，这三个数据包都已经到达了接收端的缓冲区中，如果使用**UDP协议，不管我们使用多大的接收缓冲区去接收数据，则必须有三次接收动作**，才能把所有数据包接受完。而**使用TCP协议，只要把接收数据的缓冲区大小设置在7kb以上，就能够一次把所有的数据包接收下来**，即只需要有一次接收动作。

这样问题就来了，**由于TCP协议是流传输的，它把数据当作一串数据流，所以他不知道消息的边界，即独立的消息之间是如何被分隔开的。**这便会造成消息的混淆，也就是说**不能够保证一个Send方法发出的数据被一个Recive方法**读取。Recive方法是从系统缓冲区上读取数据的，所以**只要数据缓冲区的容量足够大，该方法不单单接收第一个包的数据，可能是所有的数据。**

例如，有两台网络上的计算机，客户机发送的消息是：第一次发送abcde，第二次发送12345，服务器方接收到的可能是abcde12345（粘包），即一次性收完；也可能是第一次接收到abc，第二次接收到de123，第三次接收到45.（拆包）

注意tcp是不会丢包和失序的。

## 粘包、拆包表现形式

 现在假设客户端向服务端连续发送了两个数据包，用msg1和msg2来表示，那么服务端收到的数据可以分为三种，现列举如下

**1、正常情况**

服务器一共读取到两个数据包，第一个数据包包含客户端发出的第一条消息的完整信息，第二个包包含客户端发送的第二条完整的数据消息，这种情况属于正常情况，服务器只需要简单的从网络缓冲区去读就好了，第一次读到第一条消息的完整信息，消费完再从网络缓冲区将第二条完整的消息读出来进行消费。

![image-20200920200603376](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200920200603376.png)

**2、粘包**

接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

![image-20200920200830508](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200920200830508.png)



**3、拆包**

接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。

![image-20200920201028574](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200920201028574.png)

## 发生原因

发生TCP粘包、拆包主要是由于下面一些原因：

1. 应用程序写入的数据大小大于套接字（TCP）缓冲区大小，这将会发生拆包。比如一次要发送1500B的数据，缓冲区大小为1024B，就要拆包了
2. 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。
3. 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。比如一次要发送50B的数据，要发10次，缓冲区大小为1024B，就要粘包了
4. 接收方法不及时读取套接字缓冲区数据，这将发生粘包。

最多的是以上四种情况，2种情况粘包、2种情况拆包



## 解决粘包和拆包方法

针对这个问题，一般有3种解决方案：

1. 使用自定义协议+编解码器（使用带消息头的协议、**消息头存储消息开始标识及消息长度信息**，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。）
2. 发送端将每个数据包封装为**固定长度**（不够的可以通过补0填充），这样接收端每次从**接收缓冲区中读取固定长度**的数据就自然而然的把每个数据包拆分开来。
3. 可以在数据包之间设置边界，如**添加特殊符号作为边界**，这样，接收端通过这个边界就可以将不同的数据包拆分开。

