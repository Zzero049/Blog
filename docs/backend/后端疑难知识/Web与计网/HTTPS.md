# HTTPS协议

## HTTP安全性

基于http协议数据在互联网中传输是安全吗？

**不安全，没有加密的**

![image-20200601215524100](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200601215524100.png)

- 容易被监听 
  - http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的
- 被伪装 
  - http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求www.taobao.com,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。
- 被篡改 
  - hacker中间篡改数据后，接收方并不知道数据已经被更改

![image-20200601215540689](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200601215540689.png)

## 加密算法

因此需要进行加密，解决信息的保密性，那么常见的有哪些加密算法呢：

- 如基本的**单向加密**算法（不可逆地进行加密，每个原值加密后都一样，破解的原理是用字符集去逐个进行比对）： 

  - **BASE64** 严格地说，属于==编码格式==，而非加密算法
  - **MD5**(Message Digest algorithm 5，信息摘要算法)
  - **SHA**(Secure Hash Algorithm，安全散列算法)
  - HMAC(Hash Message Authentication Code，散列消息鉴别码)

- 复杂的**对称加密（AES、DES、PBE）**、**非对称加密算法（RSA）**： 

  - DES(Data Encryption Standard，数据加密算法)
  - PBE(Password-based encryption，基于密码验证)
  - **AES**（Advanced Encryption Standard）：使用**同一个共享秘钥**，加密解密，稍微快点
  - **RSA**(Ron Rivest, AdiShamir 和Leonard Adleman)：非对称加密，**生成秘钥对，公钥加密只有私钥可见，私钥加密公钥皆可见**，稍微慢点
  - DH(Diffie-Hellman算法，密钥一致协议)
  - DSA(Digital Signature Algorithm，数字签名)

  

  

### 单纯的对称加密和非对称加密问题

**1、单纯使用对称加密**

如果我们单纯用对称加密，服务器和浏览器都是用的同一个秘钥，那么理所当然的，黑客既可以窃取浏览器的请求报文拿到这个秘钥，可以窃取服务器的响应报文进行篡改

![image-20200601224218069](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200601224218069.png)

**2、单纯使用非对称加密**

由于非对称加密，进行公钥加密的数据只有持有私钥才可见，因此很大程度无法在公钥加密的数据上下手，但是服务器发来的私钥加密的文件，所有客户端都可以申请持有，也就是还是可以劫取响应报文进行篡改。所以**目前似乎只能保证由浏览器向服务器传输数据时的安全性**

![image-20200601224138129](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200601224138129.png)



**3、双方都用非对称加密**

我们已经理解通过**一组公钥私钥，已经可以保证单个方向传输的安全性**，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程：

1. 某网站拥有用于非对称加密的公钥A、私钥A’；浏览器拥有用于非对称加密的公钥B、私钥B’。
2. 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器把公钥B明文传输给服务器。
4. 之后浏览器向服务器传输的所有东西都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有这个私钥A’可以解密，所以能保证这条数据的安全。
5. 服务器向浏览器传输的所有东西都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。

的确可以！HTTPS的加密却没使用这种方案，为什么？最主要的原因是**非对称加密算法非常耗时**，特别是加密解密一些较大数据的时候有些力不从心，而对称加密快很多，看来必须得用对称加密，那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？

还有一点**如果攻击者拿到了服务器和客户端的公钥**，那么是不是退化成了共享秘钥的情况，我拿服务器的公钥加密的数据去非法请求服务器，也可以用客户端的公钥加密数据进行伪造再发送给客户端

## 身份认证问题

那么浏览器和服务器之间如何相互识别呢？

这就涉及了一个CA认证机构颁发的证书和签名问题，具体流程如下图所示

![image-20200601233906904](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200601233906904.png)

- **证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名；**
- 内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书；



## https解决的问题

https很好的解决了http的三个缺点（被监听、被篡改、被伪装），https不是一种新的协议，它是http+SSL/TLS的结合体，SSL是一种独立协议，所以其它协议比如smtp等也可以跟ssl结合。https改变了通信方式，它由以前的http—–>tcp，改为https——>SSL/TLS—–>tcp；https采用了非对称加密+对称加密的方式

- 防监听 
  - 数据是加密的，所以监听得到的数据是密文，hacker看不懂。
- 防伪装 
  - 伪装分为客户端伪装和服务器伪装，通信双方携带证书，证书相当于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造
- 防篡改 
  - https对数据做了摘要，篡改数据会被感知到。hacker即使从中改了数据也白搭。

## https连接过程

先是非对称锁确定服务器的身份，然后客户端再通过共享秘钥让服务器确定客户端的身份。

- 客户端发送请求到服务器端
- 服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在
- 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端
- 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
- 客户端使用共享密钥解密数据
- SSL加密建立，加密地进行握手传输

![img](https://gitee.com/zero049/MyNoteImages/raw/master/1260476-20171116160813812-635766483.png)



### 完整的过程：

​	**1. 客户端发起HTTPS请求**

　　这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

　　**2. 服务端的配置**

　　采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

　　**3. 传送证书**

　　这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

　　**4. 客户端解析证书**

　　这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

　　**5. 传送加密信息**

　　这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

　　**6. 服务段解密信息**

　　服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

　　**7. 传输加密后的信息**

　　这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

　　**8. 客户端解密信息**

　　客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

**客户端认证的通信的过程**

- 客户端需要认证的过程跟服务器端需要认证的过程基本相同，并且少了最开始的两步。这种情况都是证书存储在客户端，并且应用场景比较少，一般金融才使用，比如支付宝、银行客户端都需要安装证书



### 后续的问题

- 怎样保证公开密钥的有效性 

  - 你也许会想到，怎么保证客户端收到的公开密钥是合法的，不是伪造的，证书很好的完成了这个任务。证书由权威的第三方机构颁发，并且对公开密钥做了签名。

    

- https的缺点 

  - https保证了通信的安全，但带来了加密解密消耗计算机cpu资源的问题 ，不过，有专门的https加解密硬件服务器

  

- 各大互联网公司，百度、淘宝、支付宝、知乎都使用https协议，为什么？ 

  - 支付宝涉及到金融，所以出于安全考虑采用https这个，可以理解，为什么百度、知乎等也采用这种方式？**为了防止运营商劫持！**http通信时，运营商在数据中插入各种广告，用户看到后，怒火发到互联网公司，其实这些坏事都是运营商(移动、联通、电信)干的,**用了https，运营商就没法插播广告篡改数据了。**



## 中间人攻击

https流程大致如下：

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。

中间人的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开拿到它呀！然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. **中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）**。
4. 浏览器随机生成一个用于对称加密的密钥X，用**公钥B**（浏览器不知道公钥被替换了）加密后传给服务器。
5. **中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器**。
6. 服务器拿到后用私钥A’解密得到密钥X。

这就是**SSL劫持攻击**，对于客户端来说，**如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回**，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据

这样在双方都不会发现异常的情况下，中间人得到了密钥B。**根本原因是浏览器无法确认自己收到的公钥是不是网站自己的**。那么下一步就是解决下面这个问题：

### **如何证明浏览器收到的公钥一定是该网站的公钥？**

现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢？给网站颁发一个“身份证”？

**数字证书**

网站在使用HTTPS前，需要向“**CA机构**”申请颁发一份**数字证书**，数字证书里有证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”。然而这里又有一个显而易见的问题了，证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？身份证有一些防伪技术，数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！

**1、如何放防止数字证书被篡改？**

我们把证书内容生成一份“签名”，**比对证书内容和签名是否一致**就能察觉是否被篡改。这种技术就叫`数字签名`：

**数字签名**

这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程

![img](https://gitee.com/zero049/MyNoteImages/raw/master/v2-c351011aed3f71512b06c78423427e0a_720w.jpg)

数字签名的制作过程：

1. CA拥有非对称加密的私钥和公钥。
2. CA对证书明文信息进行hash。
3. 对hash后的值用私钥加密，得到数字签名。

明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。

那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）

浏览器验证过程：

1. 拿到证书，得到明文T，数字签名S。
2. 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
3. 用**证书里说明的hash算法对明文T进行hash得到T’。**
4. 比较S’是否等于T’，等于则表明证书可信。

为什么这样可以证明证书可信呢？我们来仔细想一下。

**2、中间人有可能篡改该证书吗？**

假设中间人篡改了证书的原文，**由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名**。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。

既然不可能篡改，那整个证书被掉包呢？

**3、中间人有可能把证书掉包吗？**

假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。

其实这并**不会发生**，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。

**4、为什么制作数字签名时需要hash一次？（TODO）**

我初学HTTPS的时候就有这个问题，似乎以上过程中hash有点多余，把hash过程去掉也能保证证书没有被篡改。

最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。

当然还有安全上的原因，这部分内容相对深一些，以后再继续完善

**5、怎么证明CA机构的公钥是可信的？**

你们可能会发现上文中说到CA机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？
让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站/机构等”，那这个CA机构的公钥是不是也可以用数字证书来证明？没错，**操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。**

实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做**`信任链`或`数字证书链`**，也就是一连串的数字证书，**由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份**。

另外，不知你们是否遇到过网站访问不了、提示要安装证书的情况？这里安装的就是根证书。说明**浏览器不认给这个网站颁发证书的机构，那么没有该机构的根证书，你就得手动下载安装（风险自己承担XD）**。安装该机构的根证书后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。

**6、HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？**

这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就行。

**服务器会为每个浏览器（或客户端软件）维护一个session ID**，在TSL握手阶段传给浏览器，**浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下**，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！

v



 ## 与HTTP协议区别

| 协议     | HTTP                                                         | HTTPS                                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 描述     | 运行在 TCP 之上，明文传输，**客户端与服务器端都无法验证对方的身份** | 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， **是添加了加密和认证机制的 HTTP**。 |
| 端口     | 80                                                           | 443                                                          |
| 资源消耗 | 较少                                                         | 由于加解密处理，会消耗更多的 CPU 和内存资源                  |
| 证书     | 无需证书                                                     | 需要证书，而证书一般需要向认证机构购买                       |
| 加密机制 | 无                                                           | 共享密钥加密和公开密钥加密并用的混合加密机制                 |
| 安全性   | 弱                                                           | 由于加密机制，安全性强                                       |



## 总结

1、服务器向CA机构获取证书（假设这个证书伪造不了），当浏览器首次请求服务器的时候，服务器返回证书给浏览器。（证书包含：公钥+申请者与颁发者的相关信息+签名）

2、浏览器得到证书后，开始验证证书的相关信息，证书有效（没过期等）。

3、验证完证书后，如果证书有效，客户端是生成一个随机数，然后用证书中的公钥进行加密，加密后，发送给服务器，服务器用私钥进行解密，得到随机数。之后双方便开始用该随机数作为钥匙，对要传递的数据进行加密、解密。

 