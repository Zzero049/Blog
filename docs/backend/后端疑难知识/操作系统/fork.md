父进程有十个线程fork出的子进程有几个线程：父进程fork子进程时，仅仅copy调用fork的线程至子进程

**子进程会克隆哪些资源：**fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了**“写时复制“技术**，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说**，两者的虚拟空间不同，但其对应的物理空间是同一个**。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，內核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exeC，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。**fork时子进程获得父进程数据空间、堆和栈的复制**，所以变量的地址（当然是虚拟地址）也是一样的具体过程是这样的

1. fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的 private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作"，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为可写”，留给另外一个进程使用。

2. 这就是所谓的**写时复制**。正因为fork采用了这种写时复制的机制，所以fork出来子进程之后，父子进程哪个先调度呢？内核-般会先调度子进程，因为很多情况下**子进程是要马上执行exec，会凊空栈、堆。。这些和父进程共享的空间，加载新的代码段**。，这就避免了写时复制拷贝共享页面的机会。如果父进程先调度很可能写共享页面，会产生“写时复制的无用功。所以，一般是子进程先调度滴。假定父进程 malloc的指针指向0×12345678，foκk后，子进程中的指针也是指向0×12345678，但是这两个地址都是虚拟内存地址（virtual memory），经过内存地址转换后所对应的物理地址是不一样的。所以两个进城中的这两个地址相互之间没有任何关系。（注1：在理解时，你可以认为fork后，这两个相同的虚拟地址指向的是不同的物理地址，这样方便理解父子进程之间的独立性）

   （注2：但实际上，linux为了提高fork的效率，采用了 copy-on-write技术，fork后，这两个虚拟地址实际上指向相同的物理地址（内存页），只有任何一个进程试图修改这个虚拟地址里的内容前，两个虛拟地址才会指向不同的物理地址（新的物理地址的内容从原物理地址中复制得到））

机器有4G内存,系统本身占1G,如果父进程占用2G内存,fork子进程能否成功  ？写时复制，应该是可以的  