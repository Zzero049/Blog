

关于多进程和多线程，教科书上最经典的一句话是“进程是资源分配的最小单位，线程是CPU调度的最小单位”。这句话应付考试基本上够了，但如果在工作中遇到类似的选择问题，那就没有那么简单了，选的不好，会让你深受其害。所以他也是面试者最喜欢考察的题目之一。

我们按照多个不同的维度，来看看多进程和多线程的对比（注：都是相对的，不是说一个好得不得了，另一个差的无法忍受）

维度

多进程

多线程

总结

数据共享、同步

数据是分开的:共享复杂，需要用IPC;同步简单

多线程共享进程数据：共享简单；同步复杂

各有优势

内存、CPU

占用内存多，切换复杂，CPU利用率低

占用内存少，切换简单，CPU利用率高

线程占优

创建销毁、切换

创建销毁、切换复杂，速度慢 

创建销毁、切换简单，速度快 

线程占优 

编程调试

编程简单，调试简单

编程复杂，调试复杂

进程占优 

可靠性

进程间不会相互影响 

一个线程挂掉将导致整个进程挂掉

进程占优

分布式 

适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单

适应于多核分布

进程占优

 

 

然后我们来看下线程和进程间的比较

 

子进程继承父进程的属性：

子线程继承主线程的属性：

实际用户ID，实际组ID，有效用户ID，有效组ID；

附加组ID；

进程组ID；

会话ID；

控制终端；

设置用户ID标志和设置组ID标志；

当前工作目录；

根目录；

文件模式创建屏蔽字（umask）；

信号屏蔽和安排；

针对任一打开文件描述符的在执行时关闭（close-on-exec）标志；

环境；

连接的共享存储段；

存储映射；

资源限制；

进程中的所有信息对该进程的所有线程都是共享的；

可执行的程序文本；

程序的全局内存；

堆内存；

栈；

文件描述符；

信号的处理是进程中所有线程共享的（注意：如果信号的默认处理是终止该进程那么即是把信号传给某个线程也一样会将进程杀掉）；

 

父子进程之间的区别：

子线程特有的：

fork的返回值(=0子进程)；

进程ID不同；

两个进程具有不同的父进程ID；

子进程的tms_utime,tms_stime,tms_cutime以及tms_ustime均被设置为0；

不继承父进程设置的文件锁；

子进程的未处理闹钟被清除；

子进程的未处理信号集设置为空集；

线程ID；

一组寄存器值；

栈；

调度优先级和策略；

信号屏蔽字；

errno变量；

线程私有数据；



 ![image-20200529222055407](H:\Desktop\新建文件夹\Blog\docs\backend\Java必备知识\操作系统\pictures\image-20200529222055407.png)


1)需要频繁创建销毁的优先用线程。
实例：web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。
2）需要进行大量计算的优先使用线程。
所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的。
实例：图像处理、算法处理
3）强相关的处理用线程，若相关的处理用进程。
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。
一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。
4）可能扩展到多机分布的用进程，多核分布的用线程。
5）都满足需求的情况下，用你最熟悉、最拿手的方式。

 

至于”数据共享、同步“、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，只能说：没有明确的选择方法。一般有一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。
