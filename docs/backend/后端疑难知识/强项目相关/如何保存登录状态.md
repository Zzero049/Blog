一般是用session去做的

另外，由于 Session对象一般有GC的机制，一般默认1440秒内页面没有刷新动作（准确的说是没有新的请求来刷新该 PHPSESSID的生命周期），该 SESSION也就被自动回收，伴随着用户的登录就失效了。

实在想用cookie实现的话

被伪造，这是客观存在的事实，但要实现这个“记住我”，还确实就得用到COOKIE，我们能做的是尽量去提高伪造的门槛
这边仅提供一个参考的设计方案
1、将用户信息，比如一个['uid'=>'123'，'username'='testuser']的数组，序列化后成为字符串，使用**可逆加密**算法加密该字符串，写到个Key为 userinfo的 COOKIE里

2、由于可逆加密算法容易被解密，一旦加密的规则被别人猜测到以后，就可以轻易篡改这个COOKIE的内容，然后自行根据加密规则加密后伪造，所以，我们另外加入一个 infodig的COOKIE，是将以上的 userinfo的 COOKIE内容，加入sat后使用不可逆加密算法生成散列，至于sat咱们可以自己定，总之要对外保空，不可逆算法例如md5，甚至多次加盐多次md5

3、以上两个COOKIE为增强安全性，防止用户被XSS攻击后拿到，可以设置http-only属性服务端判断存在以上两个COOKIE后

1. 验证 infodig与 userinfo是否匹配（将 userinfo的内容使用生成 indig的方法计算后，与COOKIE传上来的nodg匹配是否一致）

2. infodig验证通过后，使用解密算法解密 userinfo，串，得到用户信息，如果用户信息里的uid存在用户表中，则写SESSION，通过 SESSION保持本次会话

总而言之，使用COKE记录用户信息是可行的（当然不建议把用户敏感的东西存在 COOKIE，例如邮箱、手机、甚至密码，只记录对登录有用的部分，例如uid、username等标识，以及 nickname可能会在某些地方提升用户体验），可以确定的是，这个 COOKIE对用户可见，我们要做的就是两点：1、尽量让用户看不懂，而只有我们服务端自己认识（可逆加密算法）；2、即使用户看懂了，他也不能够轻易的伪造（不可逆的散列算法