# 索引

MySQL官方对索引的定义为：**索引（Index）是帮助MySQL高效获取数据的数据结构。**提取句子主干，就可以得到索引的本质：索引是数据结构。实际上就是为了**提高==排序和查找==效率**。

**优点:**

1、类似大学图书馆建书目索引，提高数据检索的效率，**降低数据库的IO成本**

2、通过索引列对数据进行排序，降低数据排序的成本，**降低了CPU的消耗**

**缺点：**

1、实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要**占用空间**的

2、虽然索引大大**提高了査询速度，同时却会降低更新表的速度**，如对表进行 INSERT、UPDATE和 DELETE因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息

3、索引只是提高效率的一个因素，如果你的 MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询

## 索引分类

- 主键索引（PRIMARY KEY）
  - 唯一的表示，主键不可重复，一个表只能有一个主键（可以是多个字段，也叫联合主键）
- 唯一索引（UNIQUE KEY）
  - 设置成唯一索引的列，元素不能重复，一个表可以有多个唯一索引
- 常规索引（KEY/INDEX）
  - 快速定位特定数据，应加在查询条件的字段，不易添加太多常规索引，影响数据的插入，删除和修改操作
- 全文索引（FullText）
  - 快速定位数据，使用 match(属性名)  against(字符串) 关键字，比like % 性能快很多

- 复合索引：
  - 多列值组成一个索引，专门用于组合搜索，其效率大于索引合并



**主键索引和唯一索引的区别：**

1. 一个表只能有一个主键索引，但是可以有多个唯一索引
2. 主键索引一定是唯一索引，唯一索引则不一定是主键索引
3. 主键索引可以与外键构成完整性约束，唯一索引不可以
4. 唯一性索引列允许空值，而主键列不允许为空值
5. 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等

作为二级索引，叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。



**为什么推荐主键为int型自增**

1、innodb引擎要求必须建立索引，通过索引建立B+树，即使不建立，也会搜索各字段找到一个所有值都不同的字段成为索引，如果没有，就在后台自动创建一个隐藏链实现

2、int型相对其他类型如String类型占用磁盘相对更小，进行比对耗时也更小

3、自增可以保证不会浪费太多时间在B+树的调整上，UUID的string类可能会在叶子节点的有序链上其中一个结点插入导致平衡调整



## 基本语法

**1、创建：（也可以在建表就指定）**

```sql
CREATE [UNIQUE] INDEX indexName ON mytable(columnname1 {columnname2.....columnnameN})

ALTER mytable ADD [UNIQUE] INDEX [indexName] ON(columnname1 {columnname2.....columnnameN})
```

**2、删除：**

```sql
DROP INDEX indexName ON mytable
```



**3、查看**

```sql
SHOW INDEX FROM table name
```



**4、修改**
有四种方式来添加数据表的索引：

```mysql
# 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。(主键是唯一索引)
ALTER TABLE tbl_name ADD PRIMARY KEY(column_list);

# 这条语气创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
ALTER TABLE tbl_name ADD UNIQUE index_name(column_list);

# 添加普通索引，索引值可出现多次。
ALTER TABLE tbl_ame ADD INDEX index_name(column_list);

# 该语指定了索引为FULLTEXT，用于全文索引。
ALTER TABLE tbl_name ADD FULLTEXT index name(column list);
```

### 

## 索引的数据结构

- B+Tree
- Hash
- full-text
- R-Tree



**1、B+Tree**

B+树结构示意图：

- B+树的特征： 

  1、有K个孩子的节点就有K个关键字。也就是孩子数量=关键字数。

   2、非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大或最小。 

  3、非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。

   4、所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。

![img](H:\Desktop\新建文件夹\Blog\docs\backend\mysql\高级\pictures\u=2432071770,1464770626&fm=15&gp=0.jpg)

真实的情况是通过设计索引文件大小与磁盘块大小一致，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次lO，那么总共需要百万次的IO，显然成本非常非常高。



**2、Hash**

Hash索引示意图： 

键值Key通过Hash映射找到桶bucket。桶指的是一个能存储一条或多条记录的存储单位。一个桶的结构包含了一个内存指针数组，桶中的每行数据都会指向下一行，形成**链表**结构（链地址法），当遇到Hash冲突时，会在桶中进行键值的查找。 Hash冲突： 如果桶的空间小于输入的空间，不同的输入可能会映射到同一个桶中，这时就会产生Hash冲突，如果Hash冲突的量很大，就会影响读取性能。

![在这里插入图片描述](H:\Desktop\新建文件夹\Blog\docs\backend\mysql\高级\pictures\20190725093300380.jpg)



**区别：**

由于Hash索引结构和B+ 树不同，因此在索引使用上也会有差别：

（1）Hash索引不能进行**范围查询**，而B+树可以。 这是因为Hash索引指向的数据是无序的，而B+ 树的叶子节点是个有序的链表。

（2）Hash索引**不支持联合索引的最左侧原则**（即联合索引的部分索引无法使用），而B+树可以。 对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或多个索引时，联合索引无法被利用。

（3）Hash索引不支持**Order BY排序**，而B+树支持。 因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段Order By 排序优化的作用。

（4）Hash索引无法进行**模糊查询**。而B+ 树使用 LIKE 进行模糊查询的时候，LIKE后面前模糊查询（比如%开头）的话可以起到优化的作用。

（5）**Hash索引在等值查询上比B+树效率更高。** 不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字非常耗时。所以Hash索引通常不会用到重复值多的列上，比如列为性别，年龄等。



## 什么时候需要创建索引

1、主键自动建立唯一索引

2、频繁作为查询条件的字段应该创建索引（比如银行卡号，手机号，微信号）

3、查询中与其它表关联的字段，外键关系建立索引

4、频繁更新的字段不适合创建索引（因为每次更新不单单是更新了记录还会更新索引）

5、Where条件里用不到的字段不创建索引

6、单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）

7、查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度（即比如经常要orderby，尽量出现在索引的尾部，防止索引全失效）

8、查询中统计或者分组字段



## 什么时候不建索引

1、表记录太少

2、经常增删的表

3、数据重复且分布平均的表字段（该键的值差异不大），因此应该只为最经常查询和最经常排序的数据列建立索引。

注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。