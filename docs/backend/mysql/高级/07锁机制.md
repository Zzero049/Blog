# 锁
锁是计算机协调多个进程或线程并发访问某一资源的机制。
在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 锁分类

对数据操作的类型：
- 读锁（共享锁）
针对同一份数据，多个读操作可以同时进行而不会互相影响。
- 写锁（排他锁）
当前写操作没有完成前，它会阻断其他写锁和读锁。

从对数据操作的粒度分：
- 表锁
- 行锁
- 页锁

### 表锁(尽量用于读)
偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。
MySQL的表级锁有两种模式：
表共享读锁（Table Read Lock）
表独占写锁（Table Write Lock）

```sql
# 建表
CREATE TABLE mylock(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(20)
)ENGINE	MYISAM;

# 插入
INSERT INTO mylock(NAME) VALUES('a');
INSERT INTO mylock(NAME) VALUES('b');
INSERT INTO mylock(NAME) VALUES('c');
INSERT INTO mylock(NAME) VALUES('d');
INSERT INTO mylock(NAME) VALUES('e');

```
锁表命令
lock table 表1名 read/write[,表2名 read/write];
解锁命令
unlock tables;
```sql
# 查看表上加的锁
SHOW OPEN TABLES;
# 加锁
lock table mylock read, test01 write;
# 解锁
unlock tables;
```


![image-20200514181721970](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200514181721970.png)


**<br>加入读锁**
会话1对表mytable进行加读锁
1. 别的会话可以读mytable
2. 别的会话写mytable会堵塞，直到会话1释放锁
3. 会话1可以读mytable，但是不可以读别的表
4. 会话1不可以写mytable

**<br>加入写锁**
会话1对表mytable进行加写锁
1. 别的会话查询mytable堵塞，直到会话1释放锁
2. 别的会话写mytable会堵塞，直到会话1释放锁
1. 会话1可以读mytable，但是不可以读别的表
4. 会话1可以写mytable

简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。

#### 表锁分析
可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定：
```sql
show status like 'table%';
```
![image-20200514181748826](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200514181748826.png)

这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：

**Table_locks_immediate：** 产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1；
**Table_locks_waited：** 出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在着较严重的表级锁争用情况；

此外，Myisam的读写锁调度是写优先，这也是myisam不适合做写为主表的司。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞

### 行锁（尽量用于写）
偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

事务之间对同一行的修改是需要阻塞的，但不同行之间不需要阻塞，而且等级是Repeatable read（RR）可以避免脏读（读到没提交的事务），不可重复读（本次事务提交前读取到的数据一致）

| 隔离级别                  | 脏读 | 不可重复读 | 幻读 |
| ------------------------- | :--: | :--------: | :--: |
| read uncommitted:读未提交 |  ×   |     ×      |  ×   |
| read committed：读已提交  |  √   |     ×      |  ×   |
| repeatable read：可重复读 |  √   |     √      |  ×   |
| serializable：串行化      |  √   |     √      |  √   |

#### 索引失效行锁变表锁 

```sql
# session1
# 事务1
# a字段是varchar型，进行自动转换，索引失效
update innodb_lock set a=41 where b=400;
# session2
# 事务2尝试修改不同行，但被阻塞
update innodb_lock set a=2 where b=500;
```

#### 间隙锁危害
当我们用**范围条件**而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；**对于键值在条件范围内但并不存在的记录**，叫做“间隙（GAP）”，InnoDB也会对这个**“间隙”加锁**，这种锁机制就是所谓的间隙锁（Next-Key锁）。

例子：

假如有2个事务，事务1当a>1 and a<6修改b（注意a没有2），事务2，插入一条a为2的数据，此时事务2会等待事务1提交才执行。

如果表中目前有已有的id为（11 ， 12）

那么就锁住（12，无穷大）

如果表中目前已有的id为（11 ， 30）

那么就锁住（11，30）

![image-20200514181815526](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200514181815526.png)

因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在
间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害

#### 锁定一行
事实上一个客户端进行update某行会锁定一行，如果要锁定一行并进行复杂操作，可以如下操作：
```sql
# 第一步
begin;
# 第二步
select * from innodb_lock where a=8 for update;
# 第三步
 (业务代码)
# 第四步
commit;
```

Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。
但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。


#### 行锁分析

```sql
show status like 'innodb_row_lock%';
```

对各个状态量的说明如下：
Innodb_row_lock_current_waits：当前正在等待锁定的数量；
**Innodb_row_lock_time：** 从系统启动到现在锁定总时间长度；**Innodb_row_lock_time_avg：** 每次等待所花平均时间；
Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；**Innodb_row_lock_waits：** 系统启动后到现在总共等待的次数；

### 优化建议
- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
- 合理设计索引，尽量缩小锁的范围
- 尽可能较少检索条件，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度
- 尽可能低级别事务隔离



## 死锁

① 设置锁优先级：提前设置优先级，如果运行A和B出现死锁，优先级低的回滚，优先级高的先执行，这样即可解决死锁问题。
② 以固定顺序访问：设定一个顺序，比如先A后B，或者先B后A，保证不管在什么时候都尊重这个顺序（通常是按ID大小的顺序），这样就会减少死锁发生的概率了。
③ 设置锁超时时间set lock_timeout：尝试获取锁的时候加一个锁超时时间，超过这个时间放弃对该锁请求。比如设置A的超时时间为10毫秒，B为100毫秒，A试了10毫秒以后获取不到资源，然后会自动断开，A断开了，这时B就可以获取资源了，避免了死锁。（但是这个方法不太好的地方在于，还需要对A再提交一次，而且timeout时间需要综合很多其他因素去设置）
④ 对所使用的数据全部加锁：每一个事务一次就将所有要使用到的数据全部加锁，否则就不允许执行，比如A在给B转钱的时候，会使用到A账户转账前，A相互转账后，B账户转账前，B账户转账后，所以就算是A给B转账，也要把A.B账户所有信息都一起加锁（这样B想给A转账也不行，因为被锁住了，不过这个还是傻，效率很低，可能又会带来其他死锁问题）



