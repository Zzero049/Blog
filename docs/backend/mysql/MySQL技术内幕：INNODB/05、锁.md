# 5 锁

锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源（不只是行记录）的并发访问。InnodB存储引擎会在行级别上对表数据上锁，这固然不错。不过 InnodB存储引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保证一致性，必须有锁的介入。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。

另一点需要理解的是，虽然现在数据库系统做得越来越类似，但是有多少种数据库，就可能有多少种锁的实现方法。在SQL语法层面，因为SQL标准的存在，要熟悉多个关系数据库系统并不是一件难事。而对于锁，你可能对某个特定的关系数据库系统的锁定模型有一定的经验，但这并不意味着你知道其他数据库。在使用 InnoDB存储引擎之前，我还使用过 MySQL的 MyISAM和 NDB Cluster存储引擎；在使用 MySQL之前，我还使用过Microsoft SQL Server、Oracle等数据库，但它们对于锁的实现完全不同。

**对于 MyISAM引擎来说，其锁是表锁。并发情况下的读没有问题，但是并发插入时的性能就要差一些了**，若插入是在“底部”的情况，MyISAM引擎还是可以有一定的并发操作。对于 Microsoft SQL Server来说，在 Microsoft SQL Server2005版本之前都是页锁的，相对表锁的 MyIsAM引擎来说，并发性能有所提高。到2005版本，Microsoft SQL Server开始支持乐观并发和悲观并发。在乐观并发下开始支持行级锁，但是其实现方式与 InnoDB存储引擎的实现方式完全不同。你会发现在 Microsoft SQL Server下，锁是一种稀有的资源，锁越多，开销就越大，因此它会有锁升级。在这种情况下，行锁会升级到表锁，这时并发的性能又回到了以前。

**InnoDB存储引擎锁的实现和 Oracle非常类似，提供一致性的非锁定读、行级锁支持，行级锁没有相关的开销，可以同时得到并发性和一致性。**

## 5.1 InnoDB存储引擎中的锁

### 5.1.1 锁的类型

InnoDB存储引擊实现了如下**两种标准的<font color="red">行级锁</font>：**

- 共享锁（S Lock），允许事务读一行数据。
- 排他锁（X Lock），允许事务删除或者更新一行数据。

当一个事务已经获得了行r的共享锁，那么另外的事务可以立即获得行r的共享锁，因为读取并没有改变行r的数据，我们称这种情况为锁兼容。但如果有事务想获得行r的排他锁，则它必须等待事务释放行r上的共享锁——这种情况我们称为锁不兼容。表6-1列出了共享锁和排他锁的兼容性。

![image-20201013025403877](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013025403877.png)

**InnoDB存储引擎支持多粒度锁定，这种锁定允许在行级上的锁和表级上的锁同时存在。**为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，我们**称之为意向锁。意向锁是表级别的锁**，其设计目的主要是为了在一个事务中揭示下一行将被请求的锁的类型。InnoDB存储引擎支持两种意向锁:

- 意向共享锁（IS Lock），事务想要获得一个表中某几行的共享锁。
- 意向排他锁（IX Lock），事务想要获得一个表中某几行的排他锁。

例子：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。

**q1:为什么意向锁是表级锁呢？**

当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）；

（1）如果意向锁是行锁，则需要遍历每一行数据去确认；

（2）如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。

**q2:意向锁怎么支持表锁和行锁并存？**

（1）首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。

（2）如果事务A对某一行上锁，其他事务就不可能修改这一行。这与“事务B锁住整个表就能修改表中的任意一行”形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如q1的答案中，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。

兼容性如下表：

1. 当事务A对某个数据范围（行或表）上了“某锁”后，另一个事务B是否能在这个数据范围上“某锁”。
2. 意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。
3. 表级S锁和X、IX锁不兼容：因为上了表级S锁后，不允许其他事务再加X锁。
4. 表级X锁和 IS、IX、S、X不兼容：因为上了表级X锁后，会修改数据，所以即使是行级排他锁，因为表级锁定的行肯定包括行级锁定的行，所以表级X和IX、X都不兼容。

**注意：因为意向锁之间相互兼容，所以意向锁对行级锁之间是不冲突的。比如A申请user表的意向共享锁，并用行级锁锁住id=5这行数据；B申请user表的意向排他锁，并锁住id=6这行数据，这是完全不冲突的**

| 是否冲突（事务A先加锁） |  IS  |  IX  | S（表级） | X（表级） |
| :---------------------: | :--: | :--: | :-------: | :-------: |
|           IS            | 兼容 | 兼容 |   兼容    |   冲突    |
|           IX            | 兼容 | 兼容 |   冲突    |   冲突    |
|            S            | 兼容 | 冲突 |   兼容    |   冲突    |
|            X            | 冲突 | 冲突 |   冲突    |   冲突    |

可以通过 SHOW ENGINE INNODB STATU命令来查看当前请求锁的信息：

![image-20201013031720122](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013031720122.png)

![image-20201013031517262](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013031517262.png)

![image-20201013031533591](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013031533591.png)

可以看到SQL语句 `select * from t where a<4 lock in share mode`在等待，RECORD LOCKS space id 30 page no 3 n bits 72 index PRiMAry of table'test.'t'trx id 48B89BD lock_mode x locks rec but not gap表示锁住的资源。**locks rec but not gap代表锁住是一个索引，不是一个范围。（行锁）**

在 InnoDB Plugin之前，我们只能通过 SHOW FULL PROCESSLIST、SHOW ENGINE INNODB STATUS等命令来查看当前的数据库请求，然后再判断当前事务中锁的情况。新版本的 InnoDB Plugin中，在 INFORMATION_SCHEMA架构下添加了 INNODE_TRX 、INNODB_LOCKS、INNODB LOCK_WAITS。通过这三张表，可以更简单地监控当前的事务并分析可能存在的锁的问题。通过实例我们来分析这三张表，先看表 INNODB_TRX ，由8个字段组成：

- trx_id：InnoDB存储引擎内部唯一的事务ID 
- trx state：当前事务的状态。
- trx started：事务的开始时间。
- trx_requested_lock_id：等待的锁ID。如tx_state的状态为 LOCK WAIT，那么该值代表当前的事务等待之前事务占用锁资源的ID。若 trx state不是 LOCK WAIT，则该值为NULL。
- itrx_wait started：事务等待开始的时间。
- trx_weight：事务的权重，反映了一个事务修改和锁住的行数。在 InnoDB存储引擎中，当发生死锁需要回滚时，InnoDB存储引擎会选择该值最小的进行回滚。
- trx_mysql thread_id：MySQLI中的线程ID，SHOW PROCESSLIST显示的结果。
- trx_query：事务运行的SQL语句。在实际使用中发现，该值有时会显示为NULL（不知道是不是Bug）。

一个具体的例子如下：

![image-20201013032334568](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013032334568.png)

可以看到，事务730FEE当前正在运行，而事务7311F4目前处于“LOCK WAIT”状态，运行的SQL语句是 `select * from parent lock in share mode`。这个只是显示了当前运行的InnoDB的事务，并不能判断锁的一些情况，如果需要查看锁，则需要 INNODB_LOCKS表，该表由如下字段组成：

- lock_id：锁的ID。
- lock_trx id：事务ID。
- lock_mode：锁的模式。
- lock_type：锁的类型，表锁还是行锁。
- lock_table：要加锁的表。

- lock_index：锁的索引
- lock_space：InnoDB存储引擎表空间的ID号。
- lock_page：被锁住的页的数量。若是表锁，则该值为NULL。
- lock_rec：被锁住的行的数量。若是表锁，则该值为NULL。
- lock_data：被锁住的行的主键值。当是表锁时，该值为NULL。

接着上面的例子，我们继续查看 INNODB LOCKS表：

![image-20201013032517798](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013032517798.png)

这次可能看到当前锁的信息了，ID为730FEE的事务向表 parent加了一个Ⅹ的行锁，ID为7311F4的事务向表 parent申请了一个S的行锁。lock data都是1，申请相同的资源，因此会有等待。这也可以解释 INNODB TRX中为什么一个事务的 trx state是“RUNNING”，另一个是“LOCK WAIT”了。

另外需要注意的是，我发现lock_data这个值并非是“可信”的值。例如当我们运行个范围査找时，lock_data可能只返回第一行的主键值。另一个不能忽视的是，如果当前资源被锁住了，与此同时，由于锁住的页因为 InnoDB存储引擎缓冲池的容量，而导致替换缓冲池该页，当查看 INNODB_LOCKS表时，该值会显示为NULL，即 InnodB存储引擎不会从磁盘进行再一次査找。(?)

查处了每张表上锁的情况后，我们可以来判断由此而引发的等待情况了。当事务较小时，我们人为地、直观地就可以进行判断了。但是当事务量非常大，锁和等待也时常发生时，这个时候不容易判断，但是通过 INNODB_LOCK_WAITS，可以很直观地反映出当前的等待。INNODB_LOCK_WATS由4个字段组成：

- requesting_trx_id：申请锁资源的事务ID 
- requesting_lock_id：申请的锁的ID 
- blocking_trx_id：阻塞的事务ID。(持有锁的事务)
- blocking_trx_id：阻塞的锁的ID。

接着上面的例子，运行如下查询：

![image-20201013032941561](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013032941561.png)

这次我们可以清楚直观地看到哪个事务阻塞了另一个事务。



### 5.1.2 一致性非锁定读操作（MVCC）

**一致性的非锁定行读（consistent nonlocking read）是指 InnodB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行 DELETE、UPDATE操作，这时读取操作不会因此而会等待行上锁的释放，相反，<font color="red">InnoDB存储引擎会去读取行的一个快照数据。</font>**如图6-1所示：

![image-20201013155915440](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013155915440.png)

图6-1直观地展现了 InnoDB存储引擎一致性的非锁定读。之所以称其为非锁定读，因为**不需要等待访问的行上X锁的释放。快照数据是指该行之前版本的数据，该实现是通过Undo段来实现。**而Undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。
此外，读取快照数据是不需要上锁的，因为没有必要对历史的数据进行修改

可以看到，非锁定读的机制大大提高了数据读取的并发性，在 InnoDB存储引擎默认设置下，这是默认的读取方式，即读取不会占用和等待表上的锁。但是在不同事务隔离级别下，读取的方式不同，并不是每个事务隔离级别下读取的都是一致性读。同样，即使都是使用一致性读，但是对于快照数据的定义也不相同。
通过图6-1我们知道，快照数据其实就是当前行数据之前的历史版本，可能有多个版本。就图6-1显示的，一个行可能有不止一个快照数据。我们称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制（Multi Version Concurrency Control，MVCC）。
在 Read committed和 Repeatable read（InnodB存储引擎的默认事务隔离级别）下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同。**在Read Committed事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。在 Repeatable事务隔离级别下和 Repeatable Read事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。**我们来看个例子，在一个 MySQL的连接会话A中执行如下事务：

![image-20201013160613822](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013160613822.png)

会话A中事务已 Begin（开始），读取了id=1的数据，但是没有结束事务。这时我们再开启另一个会话B，这样可以模拟并发的情况，然后对会话B做如下操作

![image-20201013160630871](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013160630871.png)

会话B中将id=1的行修改为d=3，但是事务同样没有提交，这样id=1的行其实加了一个Ⅹ锁。这时如果再在会话A中读取id=1的数据，根据 InnodB存储引擎的特性，在Read Committed和 Repeatable Read的事务隔离级别下，会使用非锁定的一致性读。接着，我们在会话B中提交上次的事务。(B未提交两个级别都是能读到id=1)

会话B提交事务后，这时在会话A中再运行 select*from parent where id=1的SQL语句，在 Read committed和 Repeatable事务隔离级别下得到的结果就不一样了。对于Read Committed的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照（fresh snapshot）。在上述例子中，因为会话B已经提交了事务，所以Read Committed事务隔离级别下会得到如下结果

![image-20201013160907417](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013160907417.png)

对于 Repeatable的事务隔离级别，总是读取事务开始时的行数据。因此对于 Repeatable Read事务隔离级别，其结果如下：

![image-20201013160926884](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013160926884.png)

下面将从时间的角度展现上述演示的示例。对于 **Read Committed**的事务隔离级别而言，从数据库理论的角度来看，其实**违反了事务ACID中的的特性，即隔离性**

![image-20201013160958380](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013160958380.png)



### 5.1.3 select ... for update & select ... lock in share mode(当前读)

在默认情况下，InnoDB存储引擎的 SELECT操作使用一致性非锁定读。

但是在某些情况下，我们需要对读取操作进行加锁。InnoDB存储引擎对于 SELECT语句支持两种加锁操作

- **SELECT….FOR UPDATE对读取的行记录加一个X锁**。其他事务想在这些行上加任何锁都会被阻塞。
- **SELECT…LOCK IN SHARE MODE对读取的行记录加一个S锁**。其他事务可以向被锁定的记录邡S锁，但是对于加X锁，则会被阻塞。

对于一致性非锁定读，即使读取的行已被使用 SELECT…FOR UPDATE，也是可以进行读取的。另外，SELECT…FOR UPDATE，SELECT…LOCK IN SHARE MODE必须在个事务中，当事务提交了，锁也就释放了。因为在使用上述两句 SELECT锁定语句时，务必加上 BEGIN、START TRANSACTION或者 SET AUTOCOMMIT=0。



### 5.1.4 自增长和锁

自增长在数据库中是非常常见的一种属性，也是很多DBA或开发人员首选的主键方式。在 InnoDB存储引擎的内存结构中，**对每个含有自增长值的表都有一个自增长计数器（auto Increment counter）。**当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，执行如下的语句来得到计数器的值：

```sql
SELECT MAX(auto_inc_col) FROM t FOR UPDATE
```

插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称做AUTO-INC Locking。这种锁其实是釆用一种**特殊的表锁机制**，为了提高插入的性能，**锁不是在个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放。**

虽然AUTO-INC Locking从一定程度上提高了并发插入的效率，但这里还是存在一些问题。（其实就是在插入的时候会阻塞）

首先，**对于有自增长值的列的并发插入性能较差，所以必须等待前一个插入的完成（虽然不用等待事务的完成）。**

其次，**对于 INSERT、SELECT的大数据量的插入，会影响插入的性能，因为另一个事务中的插入会被阻塞。**

从 MySQL5.1.22版本开始，**InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制**，这种机制大大提高了自增长值插入的性能。并且从 MySQL5.1.22版本开始，InnoDB存储引擎提供了一个参数 innodb autoinc_lock_mode，默认值为1。在继续讨论新的自增长实现方式之前，我们需要对自增长的插入进行分类。对于插入前就能确定插入行数的键，通过互斥信号量（mutex）去对内存中的计数器累加。对于插入前不能确定行数的键，还是通过AUTO-INC Locking机制，先执行`SELECT MAX(auto_inc_col) FROM t FOR UPDATE`获得行数

另外，InnodB存储引擎下，自增长值的列必须是索引，并且是索引的第一个列，如果是第二个列则会报错；而 MyISAM存储引擎则没有这个问题

![image-20201013163424727](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013163424727.png)

![image-20201013163430270](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013163430270.png)



### 5.1.5 外键和锁

前面已经介绍了外键，外键主要用于引用完整性的约束检查。**在 InnodB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引**，因为这样可以避免表锁——这比 Oracle做得好，Oracle不会自动添加索引，用户必须自己手工添加，这也是导致很多死锁问题产生的原因。

**对于外键值的插入或者更新，首先需要查询父表中的记录，即 SELECT父表。但是<font color="red">对于父表的 SELECT操作，不是使用一致性非锁定读的方式</font>，因为这样会发生数据不一致的问题，因此这时<font color="red">使用的是 SELECT….LOCK IN SHARE MODE方式，主动对父表加一个S锁</font>。如果这时父表上已经这样加X锁，那么子表上的操作会被阻塞**，如下面的例子所示：

![image-20201013164020767](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013164020767.png)

上面的例子中，两个事务都没有 COMMIT或者 ROLLBACK，这时 Session b的操作会被阻塞。因为id=3的父表上在 Session a中已经加了一个X锁，而这时我们需要对父表中id=3的行加一个S锁，这时 Insert的操作会被阻塞。设想如果访问父表时，使用的是一致性的非锁定读，这时 Session b会读到父表有id=3的记录，可以进行插入操作。但是如果Session a对事务提交了，则父表中就没有id=3的记录。数据在父子表就会存在不一致的情况。如果我们查询 INNODB_LOCKS表，会得到如下结果：

![image-20201013164743689](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013164743689.png)

![image-20201013164756404](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013164756404.png)



## 5.2 锁的算法

InnoDB存储引擎有3中行锁的算法设计，分别是：

- **Record Lock：单个行记录上的锁。**
- **Gap Lock**：间隙锁，**锁定一个范围，但不包含记录本身。**
- **Next-Key Lock**：Gap Lock+ Record lock，**锁定一个范围，并且锁定记录本身。**

**Record lock总是会去锁住索引记录。如果 InnoDB存储引擎表建立的时候没有设置任何一个索引，这时 InnoDB存储引擎会使用隐式的主键来进行锁定。**

Next-Key Lock是结合了 Gap Lock和 Record Lock的一种锁定算法，在 Next-Key Lock算法下，InnoDB对于行的査询都是采用这种锁定算法。对于不同SQL查询语句，可能设置共享的（Share）Next-Key Lock和排他的（exlusive）Next-Key Lock。

可以通过一个例子来演示 Next-Key Lock的锁定算法，建立一张表t，插入值为1、2、3、4、7、8的6条记录。

![image-20201013165153081](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013165153081.png)

接着开启两个会话，会话A在一个事务中执行 `select * from t where a<6 lock in share node`，会话B中，插人小于6或者等于6的记录，如下所示：

![image-20201013173413096](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013173413096.png)

在这种情况下，不论插入的记录是5还是6，都会被锁定。因为在 Next-Key Lock算法下，锁定的是（-∞，6）这个数值区间的所有数值。但是插入9这个数值是可以的，因为该记录不在锁定的范围内，而对于单个值的索引查询，不需要用到 Gap Lock，只要加一个Record lock即可，因此 InnoDB存储引擎会自己选一个最小的算法模型。同样，对于上面的表t，进行如下操作：

![image-20201013174641091](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013174641091.png)

这时插入记录5或6都是可行的了。需要注意的是，上面演示的两个例子都是在 InnoDB的默认配置下，即事务的隔离级别为 REPEATABLE READ的模式下。因为在 REPEATABLE READ模式下，Next-Key Lock算法是默认的行记录锁定算法。



**mysql锁的几个实现原理：**

**意象锁：**

当行锁存在时，表锁无法拿到。意象锁是一个标志，当标志位TRUE时表示已经有人拿到了意象锁，在这个时候就无法锁表了

**临键锁（行锁默认算法，next-key lock）：**

当type=range使用范围查询索引update时候有数据命中，InnoDB会锁上Btree当前区间和下一个区间。

1、4、7、10 一共分为5个区间，当范围查询>5且<9的时候理论上只有7会上锁，实际上会锁(4,7]和(7,10]两个区间

**间隙锁（gap lock）：**

临键锁查询记录不存在的时候，会退化成间隙锁，锁到了一个闭区间，只存在RR隔离级别

1、4、7、10 一共分为5个区间，当范围查询>4且<7的时候没有索引命中，这个时候会锁上（4,7）区间。

**记录锁：（record lock）**

当索引为type=eq-ref 唯一性（主键、唯一）索引，条件为精确匹配，退化成记录锁



## 5.3 锁问题

### 5.3.1 丢失更新

（1）事务T1查询一行数据，放入本地内存，并显示给一个终端用户 User。

（2）事务T2也查询该行数据，并将取得的数据显示给终端用户User2。

（3）User1修改这行记录，更新数据库并提交。

（4）User2修改这行记录，更新数据库并提交

显然，这个过程中用户 User1的修改更新操作“丢失”了。这可能会发生一个恐怖的结果。设想银行丢失了更新操作：**一个用户账户中有10000元人民币，他用两个网上银行的客户端转账，第一次转9000人民币，因为网络和数据的关系，这时需要等待。但是如果这时用户可以操作另一个网上银行客户端，转账1元。如果最终两笔操作都成功了，用户的账号余款是9999人民币，第一转的9000人民币并没有得到更新。**也许有人会说，不对，我的网银是绑定 USB Key的，不会发生这种情况——通过 USB Key登录也许可以解决这个问题，但是更重要的是，要在数据库层解决这个问题，以避免任何可能发生丢失更新的情况。

要避免丢失更新发生，其实需要让这种情况下的**事务变成串行操作（加排他锁即可）**，而不是并发的操作。即在上述四种的第（1）种情况下，对用户读取的记录加上一个排他锁，同样，发生第（2）种情况下的操作时，用户也需要加一个排他锁。这种情况下，第（2）步就必须等待第（1）、（3）步完成，最后完成第（4）步，如以下所示：

![image-20201013222448117](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013222448117.png)

### 5.3.2 脏读

理解脏读之前，需要理解脏数据的概念。脏数据和脏页有所不同。脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘，即数据库实例内存中的页和磁盘的页中的数据是不一致的，当然在刷新到磁盘之前，日志都已经被写入了重做日志文件中。而所谓脏数据，是指在缓冲池中被修改的数据，并且还没有被提交（commit）。

对于脏页的读取，是非常正常的。脏页是因为数据库实例内存和磁盘的异步同步造成的，这并不影响数据的一致性。并且因为是异步的，因此可以带来性能的提高。而脏数据却不同，脏数据是指未提交的数据。如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，则显然违反了数据库的隔离性。

脏读指的就是**在不同的事务下，可以读到其他事务修改但未提交的数据**，简单来说，就是可以读到脏数据。

脏读现象在生产环境中并不常发生。从上面的例子中就可以发现，**脏读发生的条件是需要事务的隔离级别为 READ UNCOMMITTED**，而目前绝大部分的数据库都至少设置成READ COMMITTED。InnodB存储引擎默认的事务隔离级别为 READ REPEATABLE，Microsoft SQL Server数据库为 READ COMMITTED，Oracle数据库同样也是READ COMMITTED。



### 5.3.3 不可重复读+幻读（mysql认为不可重复读和幻读是一类问题）

不可重复读是指在一个事务内多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能是不一样的。这样就发生了在**一个事务内两次读到的数据是不一样的**，因此称为不可重复读。

不可重复读和脏读的区别是：脏读是读到未提交的数据；而不可重复读读到的确实是已经提交的数据，但是其违反了数据库事务一致性的要求。举例来说，假设事务A查询账户余额为100，事务B开始，并修改余额为200并提交，此时事务A再去查，发现账户余额为200

**一般来说，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来很大的问题。**因此，很多数据库厂商（如 Oracle、Microsoft SQL Server）将其数据库事务的默认隔离级别设置为 READ COMMITTED，在这种隔离级别下允许不可重复读的现象。
**InnodB存储引擎中，通过使用Next-Key lock算法来避免不可重复读的问题。**在MySQL官方文档中，将不可重复读定义为 Phantom problem，即**幻象**问题。在Next-Key Lock算法下，对于索引的扫描，不仅仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围（gap）。因此对于这个范围内的插入都是不允许的。这样就避免了另外的事务在这个范围内插入数据导致的不可重复读的问题。因此，InnoDB存储引擎的默认事务隔离级别是READ REPEATABLE，**采用 Next-Key Lock算法，就避免了不可重复读的现象。（当前读），对于快照读，通过MVCC解决不可重复读和幻读。**

**但是mysql innodb只在一定程度上避免了一些幻读，但明没有完全解决幻读。**

**快照读（select）:**

1：一个session永远读不到另外一个session提交的数据，避免了幻读

2：一个session在执行过程中另外一个session插入了一条记录并提交，那么在当前session重复插入的时候唯一索引冲突，明明没数据为什么冲突了？再次查询并无多数据，但是冲突提醒变相的出现了幻读。

3：一个session在执行过程中另外一个session插入了一条记录并提交，那么在当前session中修改另外一个session插入的数据提示会无数据受影响，但是再次查询多了条数据？出现幻读。

**当前读（select for update）：**

1：一个session在当前读过程中没有用到索引，其他session无法插入数据，update锁了全表，避免幻读。

2：一个session在当前读过程中用到了范围索引，那么其他session也会因为next-key lock 或gap-lock的情况无法插入，避免幻读。



## 5.4 阻塞

因为不同锁之间的兼容性关系，所以在有些时刻，一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源。**在 InnoDB存储引擎的源代码中，用 Mutex数据结构来实现锁。在访问资源前需要用 mutex enter函数进行申请，在资源访问或修改完毕后立即执行mutex exit函数。**当一个资源已被一个事务占有时，另一个事务执行 mutex enter函数会发生等待，这就是阻塞。阻塞并不是一件坏事，阻塞是为了保证事务可以并发并且正常运行。

在 InnoDB存储引擎中，**参数 innodb_lock_wait_timeout用来控制等待的时间（默认是50秒）**，innodb rollback on timeout用来设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）。参数innodb_lock_wait_timeout是动态的，可以在 MySQL数据库运行时进行调整，而 **innodb_rollback_on timeout是静态的，不可在启动时进行修改。**

![image-20201013232315407](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013232315407.png)

需要牢记的是，默认情况下 InnodB存储引擎不会回滚超时引发的错误异常。其实InnOdB存储引擎在大部分情况下都不会对异常进行回滚。如在一个会话中执行了如下语句：

![image-20201013232659586](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013232659586.png)

会话A中开启了一个事务，Next-Key lock算法下锁定了小于4的所有记录（其实也锁定了4这个记录）。在另一个会话中执行如下语句：

![image-20201013232724836](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013232724836.png)

可以看到，在会话B中插入记录5是可以的，但是插入记录3的话，因为 Next-Key Lock算法的关系，需要等待会话A中事务释放这个资源，因此等待后产生了超时。**但是在超时后，我们再进行 SELECT会发现，5这个记录并没有并回滚。**其实这时事务发生了错误，但是既没有 commit，也没有 rollback，这是十分危险的，用户必须判断是需要commit还是需要 rollback，然后再进行下一步操作。



## 5.5 死锁

如果程序是串行的，那么不可能发生死锁。死锁只发生于并发的情况，数据库就是并发进行着的程序，因此可能会发生死锁。在前面架构说到，**InnodB存储引擎有一个后台的锁监控线程，该线程负责查看可能的死锁问题，并自动告知用户。**下面的操作演示了死锁的一种经典的情况，即A等待B，B在等待A：

![image-20201013235647945](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013235647945.png)

在上述操作中，会话中的事务抛出了1213这个出错提示，即发生了死锁。死锁的原因是会话A和B的资源互相在等待。**大多数的死锁 InnodB存储自己可以侦测到，**不需要人为进行干预。但是**在上面的例子中，会话B中的事务抛出死锁异常后，会话A中马上得到了记录为2的这个资源，这其实是因为会话B中的事务发生了回滚，否则会话A中的事务是不可能得到该资源的。**你还记得上一节中所说的内容吗？**InnoDB存储引擎并不会回滚大部分的错误异常，但是死锁除外。**发现死锁后，InnoDB存储引擎会马上回滚一个事务，这点是需要注意的。如果在应用程序中捕获了1213这个错误，其实并不需要对其进行回滚Oracle数据库中产生死锁的常见原因是没有对外键添加索引，而 InnoDB存储引擎会自动对其进行添加，因此很好地避免了这种情况的发生。**人为删除外键上的索引，数据库会抛出一个异常**：

![image-20201014000246927](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201014000246927.png)

![image-20201014000256157](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201014000256157.png)

可以看到，虽然在建立子表时指定了外键，但是.InnoDB存储引擎还是自动在外键列上建立了一个索引b，而人为删除这个列却是不允许的

## 5.6 锁升级

锁升级（Lock Escalation）是指将当前锁的粒度降低（粒度越大，并发越高）。举例来说，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。如果数据库的设计中认为锁是种稀有资源，而且想避免锁的开销，那数据库中会频繁出现锁升级现象。

Microsoft SQL Server数据库的设计认为锁是一种稀有的资源，在适合的时候会自动地将行、键或者分页级锁升级为更粗粒度的表级锁。这种升级保护了系统资源，防止系统使用太多的内存来维护锁，从一定程度上提高了效率。

InnoDB存储引擎不存在锁升级的问题。在 InnoDB存储引擎中，1个锁的开销与100000个锁是一样的，都没有开销。这一点和 Oracle数据库比较类似。





