# 04 索引

InnodB存储引擎支持两种常见的索引，一种是B+树索引，另一种是哈希索引。InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。

**B+树索引就是传统意义上的索引，这是目前关系型数据库系统中最常用、最有效的索引。**B+树索引的构造类似于二叉树，根据键值（Key value）快速找到数据。需要注意的是，B+树中的B不是代表二叉（binary），而是代表平衡（balance），因为B+树是从最早的平衡二叉树演化而来，但是B+树不是一个二叉树。

一个常常被DBA忽视的问题是：**<font color="red">B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。</font>然后数据库通过把页读入内存，再在内存中进行査找，最后得到査找的数据。**



## 4.1 B+ 树

B+树的定义相信在任何一本数据结构书中都能找到，其定义十分复杂，相信这里我列出来只会让大家更困惑。因此只简要地介绍B+树：B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡査找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同层的叶节点中，各叶节点指针进行连接。我们先来看一个B+树，其高度为2，每页可存放4条记录，扇出（fan out）为5。

![image-20201013000258051](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013000258051.png)

从图5-6可以看出，所有记录都在叶节点中，并且是顺序存放的，如果我们从最左边的叶节点开始顺序遍历，可以得到所有键值的顺序排序：5、10、15、20、25、30、50、55、60、65、75、80、85、90

这里省略B+树的插入删除操作（详见数据结构）



## 4.2 B+树索引

B+树索引其本质就是B+树在数据库中的实现，但是B+索引在数据库中有一个特点就是其高扇出性，因此在数据库中，**B+树的高度一般都在2 ~ 3层，也就是对于查找某一键值的行记录，最多只需要2到3次IO**，这倒不错。因为我们知道现在一般的磁盘每秒至少可以做100次IO，2 ~ 3次的IO意味着查询时间只需0.02~003秒。

数据库中的B+树索引可以分为**聚集索引（clustered index）和辅助聚集索引（secondary index），或者说一级索引、二级索引**，但是不管是聚集还是非聚集的索引，其内部都是B+树的，即高度平衡的，叶节点存放着所有的数据。**聚集索引与非聚集索引不同的是，叶节点存放的是否是一整行的信息。**



### 4.2.1 聚集索引

之前已经介绍过了，InnodB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而**聚集索引就是按照每张表的主键构造一颗B+树，并且叶节点中存放着整张表的行记录数据，因此也让聚集索引的叶节点成为数据页。**聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，**每个数据页都通过一个双向链表来进行链接。**

**由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。**在许多情况下，查询优化器非常倾向于采用聚集索引，因为聚集索引能够让我们在索引的叶节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的査询。査询优化器能够快速发现某一段范围的数据页需要扫描。

现在我们来看一张表，我们以人为的方式让其每个页只能存放两个行记录，如：

![image-20201013005836456](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013005836456.png)

可以看到，我们表的定义和插入方式使得目前每个页只能存放两个行记录，我们用p_innodb_page_info工具来分析表空间，可得：

![image-20201013005914600](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013005914600.png)

page level为0000的即是数据页，前面的章节也对数据页进行了分析，这不是我们当前所关注的部分。我们要分析的是 page leve为0001的页，该页是B+树的根，我们来看看索引的根页中存放的数据

![image-20201013010037375](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013010037375.png)

我们直接通过页尾的 Page Directory来分析，从0063可以知道该页中行开始的位置。接着通过 Recorder header来分析，0xc063开始的值为69 6e 66 69 6d 75 6d 00，就代表infimum伪行记录。之前的5个字节01 00 02 00 1b就是 Recorder header，分析第4位到第8位的值1代表该行记录中只有一个记录（需要记住的是，InnoDe的 Page Directory是稀疏的），即 infimum记录本身。我们通过 Recorder header中最后的两个字节001b来判断下一条记录的位置，即c063+1b=c073，读取键值可得8001，就是主键为1的键值（我们制定的NT是无符号的，因此二进制是0x8001，而不是0x0001），8001后值00 00 00 04代表指向数据页的页号。以同样的方式，可以找到8002和8004这两个键值以及它们指向的数据页通过以上对于非数据页节点的分析，我们发现数据页上存放的是完整的行记录，而在非数据页的索引页中，存放的仅仅是键值以及指向数据页的偏移量，而不是一个完整的行记录。因此我们构造的这颗二叉树大致如图5-14所示。

![image-20201013010158789](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013010158789.png)

许多数据库的文档会这样告诉读者：聚集索引按照顺序物理地存储数据。如果看图5-14，可能也会有这样的感觉。但是试想，如果聚集索引必须按照特定顺序存放物理记录的话，则维护成本即显得非常之高了。所以，**聚集索引的存储并不是物理上的连续，相反是逻辑上连续的。这其中有两点：一是我们前面说过的页通过双向链表链接，页按照主键的顺序排列。另一点是每个页中的记录也是通过双向链表进行维护，物理存储上可以同样不按照主键存储。**

**聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。**叶节点的数据就是我们要查询的数据，如我们要查询一张注册用户的表，查询最后注册的10位用户，由于B+树索引是双向链表的，我们可以快速找到最后一个数据页，并取出10条记录，我们用 Explain进行分析，可得：

![image-20201013010446755](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013010446755.png)

另一个是范围查询（range query），如果要查找主键某一范围内的数据，通过叶节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可，又如：

![image-20201013010526380](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013010526380.png)

Explain得到了 MySQL的执行计划（execute plan），并且rows列给出了一个查询结果的预估返回行数。要注意的是，rows代表的是一个预估值，不是确切的值，如果我们实际进行这句SQL的查询，可以看到实际上只有9946行记录。



### 4.2.2 辅助索引

对于辅助索引（也称非聚集索引），**叶级别不包含行的全部数据。叶节点除了包含键值以外，每个叶级别中的索引行中还包含了一个书签（bookmark），该书签用来告诉InnoDB存储引擎，哪里可以找到与索引相对应的行数据。**因为 InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。下图显示了 InnodB存储引擎中辅助索引与聚集索引的关系。

![image-20201013011210642](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013011210642.png)

辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnodB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。**举例来说，如果在一颗高度为3的辅助索引树中査找数据，那么需要对这颗辅助索引遍历3次找到指定主键；如果聚集索引树的髙度同样为3，那么还需要对聚集索引进行3次査找，才能最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO来访问最终的一个数据页。**

对于**其他的一些数据库**，如 Microsoft SQL Server数据库，其**表类型有一种不是索引组织表，称为堆表**。在数据的存放按插入顺序方面，与 MySQL的 MyISAM存储引擎有些类似。堆表的特性决定了**堆表上的索引都是非聚集的**，但是堆表**没有主键**。因此这时**书签是个行标识符（row identifier，RID），可以用如“文件号：页号：槽号”的格式来定位实际的行。**

也许有人会问，堆表的非聚集索引既然不需要再通过主键对聚集索引进行查找，那不是速度会更快吗？答案是也许，在某些只读的情况下，书签为行标识符方式的非聚集索引可能会比书签为主键方式的非聚集索引快。但是考虑在OLTP（OnLine transaction Processing，在线事务处理）应用的情况下，**表可能还需要发生插入、更新、删除等DML操作。当进行这类操作时，书签为行标识符方式的非聚集索引可能需要不断更新行标识符所指向数据页的位置，这时的开销可能就会大于书签为主键方式的非聚集索引了。**

当然，在一些情况下，使用堆表的确会比索引组织表更快，但是我觉得大部分是由于存在于OLAP（On-Line Analytical Processing，在线分析处理）的应用。其次就是前面提到的，表中数据是否需要更新，并且更新会否影响到物理地址的变更。此外另一个不能忽视的是**对于排序和范围查找，索引组织表可以通过B+树的中间节点就找到要查找的所有页，然后进行读取，而堆表的特性决定了这对其是不能实现的。**最后，非聚集索引的离散读，的确是存在上述情况，但是一般的数据库都**通过实现预读（read ahead）技术来避免多次的离散读操作。**因此，具体是建堆表还是索引组织表，这取决于你的应用，不存在哪个更优的情况。这和 InnodB存储引擎好还是 MyISaM存储引擎好的问题是一样的，具体情况具体分析。

对于辅助索引，上述例子图示如下

![image-20201013011710745](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013011710745.png)



## 4.3 B+树索引的使用

这里列一些知识点：

1. MySQL数据库的优化器会通过 EXPLAIN的row字段预估查询可能得到的行（但是，预估的返回行数的值是不准确的），如果大于某一个值，则B+树会选择全表的扫表。至于这个值，根据我的经验（并没有在源代码中得到验证）一般在20%。**即当取出的数据量超过表中数据的约20%，优化器就不会使用索引，而是进行全表的扫表。**

2. 在数据库中，顺序读是指根据索引的叶节点数据就能顺序地读取所需的行数据。这个顺序只是逻辑地顺序读，在物理磁盘上可能还是随机读取。但是相对来说，物理磁盘上的数据还是比较顺序的，因为是根据区来管理的，区是64个连续页。如根据主键进行读取，或许通过辅助索引的叶节点就能读取到数据。

   随机读，**一般是指访问辅助索引叶节点不能完全得到结果的，需要根据辅助索引叶节点中的主键去找实际行数据。**因为一般来说，辅助索引和主键所在的数据段不同，因此访问是随机的方式。前一小节中的SQL语句 `select id,userid,sex,registdate into outfile 'a' from member force index(idx_regrate) where registdate<2006-04-24；`就是一句典型的随机读取。
   而**正是因为读取的方式是随机的，并且随机读的性能会远低于顺序读，因此优化器才会选择全表的扫描方式，而不是去走 idx_regdate这个辅助索引。（如果查询的内容有不在索引内的，那就要在随机找到页面了，那还不如全表扫描）**
   
   **为了提高读取的性能，InnoDB存储引擎引入了预读取技术（read ahead或者 prefetch）。**预读取是指通过一次IO请求将多个页预读取到缓冲池中，并且估计预读取的多个页马上会被访问。传统的IO请求每次只读取1个页，在传统机械硬盘较低的IOPS下，预读技术可以大大提高读取的性能。
   
   Innodb存储引擎有两个预读方法，称为随机预读取（random read ahead）和线性（linear read ahead）预读取。随机预读是指当一个区（64个连续页）中13个页也在缓冲区中，并在LRU列表的前端（即页是频繁地被访问），则 InnodB存储引擎会将这个区中剩余的所有页预读到缓冲区。线性预读基于缓冲池中页的访问模式，而不是数量。如果一个区中的24个页都被顺序地访问了，则 InnodB存储引擎会读取下一个区的所有页。



### 联合索引

联合索引是指对表上的多个列做索引。前面我们讨论的情况，都是只对表上的一个列进行了索引。联合索引的创建方法与之前介绍的一样，如：

![image-20201013022344034](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013022344034.png)

什么时候需要使用联合索引呢？在讨论这个之前，我们要来看一下联合索引内部的结果。从本质上来说，联合索引还是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2。我们来讨论两个整型列组成的联合索引，假定两个键值的名称分别为a、b，如图5-18所示。

从图5-18可以看到多个键值的B+树情况，其实和我们之前讨论的单个键值没有什么不同，键值都是排序的，通过叶节点可以逻辑上顺序地读出所有数据，就上面的例子来说即（1，1），（1，2），（2，1），（2，4），（3，1），（3，2）。数据按（a，b）的顺序进行了存放。

![image-20201013022450981](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013022450981.png)

因此，对于查询` SELECT * FROM TABLE WHERE a= xxx and b=xx`，显然是可以使用（a，b）的这个联合索引。对于单个的a列查询 `SELECT * FROM TABLE WHERE a=xXxx`是可以使用这个（a，b）索引。但是对于b列的查询 `SELECT * FROM TABLE WhERE b=xxx`，不可以使用这颗B+树索引。可以看到叶节点上的b值为1、2、1、4、1、2，显然不是排序的，因此对于b列的查询使用不到（a，b）的索引。(最左前缀原则)

联合索引的第二个好处是，可以对第二个键值进行排序。例如，在很多情况下我们都需要查询某个用户的购物情况，并按照时间排序，取出最近三次的购买记录，这时使用联合索引可以避免多一次的排序操作，因为索引本身在叶节点已经排序了。





## 4.4 哈希算法

InnoDB存储引擎中自适应哈希索引使用的是散列表（Hash Table）的数据结构。但是散列表不只存在于自适应哈希中，在每个数据库中都存在。设想一个问题，当前我的内存为128G，我怎么得到内存中的某一个被缓存的页呢？内存中查询速度很快，但是也不可能遍历所有内存。这时，对于字典操作，O（1）的散列技术就能有很好的用武之地。

哈希表（Hash table）也称散列表，由直接寻址表改进而来，所以我们先来看直接寻址表。当关键字的全域U比较小时，直接寻址是一种简单而有效的技术。假设某应用要用到一个动态集合，其中每个元素都有一个取自全域U={0，1，…，m-1}e的关键字，同时假设没有两个元素具有相同的关键字。

![](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013023622226.png)

因此，哈希表出现了，在哈希方式下，该元素处于h（k）中，亦即利用哈希函数h、根据关键字k计算出槽的位置。函数h将关键字域U映射到哈希表T[0.m-1]的槽位上，见图5-20所示。

![image-20201013023708686](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013023708686.png)

### 4.4.1 InnoDB存储引擎中的哈希算法

InnoDB存储引擎使用哈希算法对字典进行査找，**其冲突机制采用链表方式，哈希函数采用除法散列方式。**对于缓冲池页的哈希表来说，**在缓冲池中的Page页都有一个 chain指针，它指向相同哈希函数值的页。**而对于除法散列，m的取值为略大于2倍的缓冲池页数量的质数。例如：**当前参数 innodb_buffer_pool_size的设置大小为10MB，则共有640个16KB的页。那对于缓冲池页内存的哈希表来说，需要分配640×2=1280个槽，但是1280不是质数，需要取比1280略大的一个质数，应该是1399，所以在启动时会分配1399个槽的哈希表，用来哈希查询所在缓冲池中的页。(槽里面存具体页面指针即value为页面指针，key是通过表号计算得出来的）**哈希表本身需要20个字节，毎个槽需要4个字节，因此一共需要20+4×1399=5616个字节。其中哈希表的20个字节从 innodb_additional mem_pool_size中进行分配，4×1399-5596个字节从系统申请分配。因此在对 InnoDB存储引擎进行内存分配规划时，也应该规划好哈希表这部分内存，这部分内存一般从系统分配，没有参数可以控制。对于前面我们说的128GB的缓冲池内存，则分配的哈希表和槽一共需要差不多640MB的额外内存空间。

那 Innodb存储引擎对于页是怎么进行査找的呢？上面只是给出了一般的算法，怎么将要查找的页转换成自然数呢？

其实也很简单，InnodB存储引擎的表空间都有一个 space号，我们要查的应该是某个表空间的某个连续16KB的页，即偏移量 offset。InnoDB存储引擎将 space左移20位，然后加上这个 space和ofet，即关键字K= space<<20+ space+ offset，然后通过除法散列到各个槽中。

### 4.4.2 自适应哈希索引

自适应哈希索引采用之前，我们讨论哈希表的方式实现。不同的是，这又是数据库自己创建并使用的，DBA本身并不能对其进行干预。当在配置文件中启用了参数 innodb adaptive_hash_index后，数据库启动时会自动创建槽数为 innodb_buffer_pool_size./256个的哈希表。例如，对当前参数 innodb buffer-pool_size设置为10MB，则启动时 InnodB存储引擎会创建一个有10M/256=40960个槽的自适应哈希表。

自适应哈希索引经哈希函数映射到一个哈希表中，因此自适应哈希索引对于字典类型的查找非常快速，如 `SELECT * FROM TABLE WHERE index_col=xx`，但是对于范围查找就无能为力了。通过命令 SHOW ENGINE INNODB STATUS可以看到当前自适应哈希索引的使用状况，如：

![image-20201013024532523](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201013024532523.png)

现在可以看到自适应哈希索引的使用信息了，包括自适应哈希索引的大小、使用情况、每秒使用自适应哈希索引搜索的情况。需要注意的是，哈希索引只能用来搜索等值的查询，如 select*from table where index_col=Xx，而对于其他查找类型，如范围査找，是不能使用哈希索引的。因此，这里出现了non-hash searches/s的情况。hash searches:nn-hash searches可以大概知道使用哈希索引后的效率

由于自适应哈希索引是由 InnodB存储引擎自己控制的，所以这里的信息只供我们参考而已。不过我们可以通过参数 innodb_adaptive_hash_index来禁用或启动此特性，默认为开启。