HashMap是我们日常开发中几乎每天都要应用的一个集合类，它是以键值对的形式来存储我们的数据，在jdk1.7到jdk1.8之间，他是有一些区别的，其中最重要的区别有：

一是HashMap在jdk1.7的时候是采用了**数组+链表**的数据结构，在jdk1.8是使用了**数组+链表+红黑树**的一个数据结构，红黑树的使用是为了提高他的一个查询效率，因为遍历一遍链表需要的时间复杂度是O(n)，而遍历红黑树只需要O(lgn)。

二是HashMap发生hash碰撞需要在链表插入节点的时候，在jdk1.7的时候是采用头插法，而在jdk1.8的时候使用尾插法，改用尾插法的原因是头插法在多线程的情况下，可能会存在一个循环链的情况，这样我们再进行get和put时候可能导致死循环浪费cpu资源

当然jdk1.7和jdk1.8之间还有很多的优化的细节，比如hash算法进行了简化，高16位不变然后低16位结果是高16位和低16位相与，还有是一开始数组不使用空数组赋值了，而是默认赋null，还有很多细节，我可能不太记得清了，我们需要在源码里面才能把他看的更透，当然我是读过源码的啊，只是这些东西可能随着技术栈的深入记得不太清了。

然后我就用jdk1.8的实现和您聊一聊一个基本的原理

首先呢我们在创建HashMap的时候，阿里规约要求我们传入一个初始化容量，我们要将来可能要插入多少数据的前提下，我们最高传入一个初始化容量，而且这个容量最好是2的n次幂。接下来我会跟您聊为什么是2的n次幂

首先我们往HashMap put值的时候，HashMap里面的数组会被初始化，按照我们传入的初始化容量，选择一个大于这个初始化容量而又最接近他的2次幂，这么一个值作为数组长度初始化数组，初始化的之后能，会重新计算key的hash值，用该hash值与上这个初始化容量-1计算出在数组的下标，相当于取模操作，但是比取模指令更少，操作会更快。至于为什么数组长度必须是2次幂，因为要减少hash碰撞，也方便下标的计算（在数组容量内）。

当然了，在我们往里添加数据的时候，会产生两个问题，一个问题是，数组扩容，另一个问题呢是树化。

关于扩容的问题，hashMap中有一个成员变量，叫加载因子，当我们HashMap的size，大于加载因子乘以数组长度，这时候发生hash碰撞就会发生数组扩容，默认的话数组长度是16，加载因子是0.75，也就是size大于12的时候发生碰撞就会进行扩容，还有一个情况是判断树化的时候，如果数组长度小于64的话，也是先进行扩容。

当我们链表上面存储的数据足够多的时候会进行树化，当然树化是很耗时的涉及红黑树的创建，节点插入和调整，树化他的条件是链表长度大于等于8，还有另外一个约束条件，就是一个成员变量，最小树化容量，默认是64，如果数组长度不到64，他会优先选择扩容，而不是树化，也就是链表长度大于等于8，然后数组长度大于等于64时，发生树化。

然后阿里规约里面让我们传入初始化容量的目的，就是让我们少扩容，然后这个初始化容量计算方法是，我们将要传入的数据数量除以加载因子+1。

关于HashMap我跟您能聊的大概就能这么多。



