## Java内存分配
https://www.bilibili.com/video/av59814573/?p=65

Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area


栈的特点如下：
1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）
2. JVM为**每个线程**创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）
3. 栈属于**线程私有**，不能实现线程间的共享！
4. 栈的存储特性是“先进后出，后进先出"
5. 栈是由系统自动分配，速度快！栈是一个连续的内存空间！

堆的特点如下：
1. 堆用于存储创建好的**对象**和**数组**（数组也是对象）(new)
2. JVM只有一个堆；被所有线程共享3.堆是一个不连续的内存空间，分配灵活，速度慢！

方法区（又叫静态区）特点如下：
1. JVM只有一个方法区，被所有线程共享！
2. 方法区实际也是堆，只是用于存储**类、常量**相关的信息！
3. 用来存放程序中永远是不变或唯一的内容。（类信息
【Class对象】、静态变量、字符串常量等） 

## 构造器
构造器也叫构造方法（constructor），用于对象的初始器

1. 通过new关键字调用！
2. 构造器虽然有返回值，但是不能定义返回值类型（返回值的类型肯定是本类），不能在构造器里使用return返回某个值。
3. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加！
4. 构造器的方法名必须和类名一致！

### 垃圾回收机制(Garbage Collection)
Java加入了垃圾回收机制，令C++程序员最头疼的内存管理问题迎刃而解。Java程序员可以将更多的精力放到业务逻辑上而不是内存管理工作上，大大的提高了开发效率。

#### 内存管理
Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。
对象空间的分配：使用new关键字创建对象即可
对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。
#### 垃圾回收过程
任何一种垃圾回收算法一般要做两件基本事情：
1. 发现无用的对象
2. 回收无用对象占用的内存空间。
垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。
#### 垃圾回收相关算法
1. 引用计数法
堆中每个对象都有一个引用计数。被引用一次，计数加1.被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。
```java
public class Student{
    String name;
    Student friend; 
} 
    public static void main(Strins[] args){
        Student s1 =new Student(); 
        Student s2· new Student(); 
        s1. friend=s2;
        s2. friend=s1;
        s1=null;
        s2=null;
     }
}
```
2. 引用可达法（根搜索算法）
程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续这个节点的引用节点，当所有的引用节点寻找亮毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。


### 分代垃圾回收
分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象配以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老线、持久代。JVM将堆内存划分为Eden、Survivor 和Tenured/Old 空间。
1. 年轻代
所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。
2. 年老代
在年轻代中经历了N（默认15）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC（全量回收），来一次大扫除，全面清理年轻代区域和年老代区域。
3. 持久代
用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显奢影响。


* Minor GC.
用子清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制J"Survivor1"、“Survivor2"区中（这两个区，大小空间也相同，同一时刻Survivor1和urvivor2只有一个在用，一个为空）
* Major GC：
用于清理老年代区域。
* Full GC：
    用于清理年轻代、年老代区域。成本较高，会对系统性能产生影响。

#### 垃圾回收过程：
1. 新创建的对象，绝大多数都会存储在Eden中。
2. 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（新生代的垃圾回收称为（minorGC）），将无用对象清理掉，然后剩余对蒙浸榈到某个Survivor中，如S1，同时清空Eden区。
3. 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
4. 重复多次（默认15次）Survivor中没有被清理的对象，则会复制到老年代Old（Tenured）区中
5. 当Old区满了（未满时达到一定比例先用MajorGC清理），则会触发一个一次完整地垃圾回收（FullGC），代价很大。
<img src="./pictures/Annotation 2019-10-14 113915.png"  div align=center />

在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致FullGC：

1. 年老代（Tenured）被写满
2. 持久代（Perm）被写满
3. system.gc()被显式调用（程序建议GC启动，不是调用GC）
4. 上一次GC之后Heap的各域分配策略动态变化

#### 开发中容易造成内存泄漏的操作

在实际开发中，经常会造成系统的崩渍。如下这些操作我们应该注意这些使用场景。请大家学完相关内容后，回头过来温习下面的内容。不要求此处掌握相关细节。如下四种情况时最容易造成内存泄露的场景，请大家开发时一定注意：
* **创建大量无用对象**
比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。
String、StringBuilder、StringBuffer区别，详见 https://blog.csdn.net/u011702479/article/details/82262823
```java
String str="";
for（int i=0;i<10000;i++）{
    str += i;//相当手产生了10000个string对象
}
```
* **静态集合类的使用**
像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。
* **各种连接对象（IO流对象、数据库连接对象、网络连接对象）未关闭**
IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。
* **监听器的使用**
释放对象时，没有删除相应的监听器。


### this

创建一个对象分为如下四步：
1. 分配对象空间，并将对象成员变量初始化为0或空
2. 执行属性值的显式初始化
3. 执行构造方法
4. 返回对象的地址给相关的变量

this的本质就是“创建好的对象的地址”！由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表"当前对象”。



#### this最常的用法：
1. 在程序中产生二义性之处，应使用this来指明当前对象；普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。
2. 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必页位于构造方法的第一句。
3. this不能用于static方法中。

### static
在类中，用static声明的成员变量为静态成员变量，也称为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。

**静态方法只能调用静态成员**

### 静态初始化块
构造方法用于对象的初始化！静态初始化块，用于**类的初始化**操作！在静态初始化块中不能直接访问非static成员。
#### 静态初始化块执行顺序
1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。
2. 构造方法执行顺序和上面顺序一样！