# 对象

## 对象实例化

### 创建对象的方式

- new：最常见的方式
- Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public
- Constructor的newInstance(xxx)：反射的方式，可以凋用空参、带参的构造器，权限没有要求
- 使用clone：不调用任何构造器，当前类需要实现 Cloneable接囗，实现 clone()，Object的clone()是浅拷贝的
- 使用反序列化：从文件中、从网络中获取一个对象的二进制流
- 第三方库Objenesis

### 对象创建过程

先看示例：

```java
public class ObjectClassTest {
    public static void main(String[] args) {
        Object o = new Object();
    }
}
```

**从字节码角度分析**，如下

![image-20200605234822485](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200605234822485.png)



现在**从执行步骤的角度来分析：**（六个步骤）

**1、判断对象对应的类是否加载、链接、初始化**

虚拟机遇到一条new指令，首先去检查这个指令的参数能否在 Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以 Classloader+包名+类名为Key进行查找对应的class文件，如果没有找到文件，则抛出 ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的class类对象

**2、为对象分配内存**

首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。

如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

- **如果内存规整**

  - 如果内存是规整的，那么虚拟机将采用的是**指针碰撞**（Bump The Pointer）来为对象分配内存

    意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选的是 Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式，一般使用带有compact（整理）过程的收集器，使用指针碰撞

    ![image-20200606001423744](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200606001423744.png)

- **如果内存不规整**

  - 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是**空闲列表法**来为对象分配内存。

    意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为空闲列表（Free List）

**3、处理并发安全问题**

对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：

- 采用**CAS失败重试**、区域加锁保证更新的原子性

- 把内存分配的动作按照线程划分在不同的空间之中进行，即**每个线程在 Java 堆中预先分配一小块内存**，称为**本地线程分配缓冲**（Thread Local Allocation Buffer, **TLAB**）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过`-XX:+/-UseTLAB`参数来设定虚拟机是否使用TLAB。

**4、初始化分配到的空间**

所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用

**5、设置对象的对象头**

将对象的所属类（即类的元数据信息）、对象的 Hashcode和对象的GC信息、锁信息等数据存储在对象的**对象头**中。这个过程的具体设置方式取决于JVM实现

**6、执行`<init>`方法进行初始化**

在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

因此一般来说（由字节码中是否跟随有 invokespecial指令所决定），new指令之后会接着就是执行该方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。



## 对象的内存布局

主要分为**对象头、实例数据、对齐填充**（数组还有数组长度）

![image-20200609221052169](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609221052169.png)

### 对象头(TODO)

存储的数据主要分为两个部分：运行时元数据区、类型指针

- 运行时元数据区（Mark Word）（并不准确，不用记住完全，详情看锁升级，不同锁状态，对象头也相应不同，要知道下面加粗的，即使不存在对象头，也要存在栈桢中）
  - **哈希值（HashCode）**
  - **GC分代年龄**
  - 锁状态标志
  - 线程持有的锁
  - 偏向线程ID
  - 偏向时间戳

- 类型指针
  - 指向类元信息 InstanceKlass，确定该对象所的类型
- 如果是数组，还需记录数组的长度（数组也看作是对象）

### 实例数据

是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）

**规则：**

- 相同宽度的字段总是分配到一起
- 父类定义的变量会出现在子类之前
- 如果CompactField参数为true（默认参数为true），子类的窄变量可能插入到父类变量的空隙（压缩）

### 对齐填充

不是必须的，也没特别含义，仅仅起到占位符的作用



图示如下：

![image-20200606020734464](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200606020734464.png)





## 对象访问定位

JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？

通过局部变量表中保存的对象引用reference访问的，如下图所示

![image-20200606021255542](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200606021255542.png)



### 对象访问方式

有两种访问方式，一个是句柄访问，一个是使用直接指针（HotSpot采用）

- **句柄访问**

  局部变量表的对象引用指向句柄池的句柄，堆中保存了一个句柄池，句柄池中存放很多句柄，一个句柄包括两个信息：

  - 到对象实例的指针
  - 到对象类型的指针

  **优点：**引用中存储的是**稳定**的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变**句柄中**的**实例数据指针**，而**引用**本身不需要修改。

  

  ![image-20200606021654937](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200606021654937.png)

  

  

- **使用直接指针**

  局部变量表的对象引用直接指向对象，对象的类型指针再去指向类型数据

  **优势**：速度更**快**，节省了**一次指针定位**的时间开销。由于对象的访问在`Java`中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。

​	![image-20200606021757634](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200606021757634.png)

















## 面试题

- 对象在JVM中是怎么存储的？
- 对象头信息里面有哪些东西？