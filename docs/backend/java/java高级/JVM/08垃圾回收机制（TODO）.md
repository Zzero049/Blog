# 垃圾回收机制

垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。

关于垃圾收集有三个经典问题：

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

垃圾收集机制是Java的招牌能力，**极大地提高了开发效率。**如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。

## 基础概念

### 什么是垃圾

垃圾是指在运行程序中**没有任何指针指向的==对象==**，这个对象就是需要被回收的垃圾。

如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。



### 为什么需要GC

对于高级语言来说，一个基本认知是如果不进行垃圾回收，**内存迟早都会被消耗完**，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样

除了释放没用的对象，垃圾回收也可以**清除内存里的记录碎片**。碎片整理将所占用的堆内存移到堆的一端，**以便 JVM 将整理出的内存分配给新的对象。**

随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化



### 早期的垃圾回收

**在早期的C/C++时代，垃圾回收基本上是手工进行的。**开发人员可以使用new关键字进行内存申请，并使用 delete关键字进行内存释放。比如以下代码：

![image-20200607134953041](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607134953041.png)

这种方式可以灵活控制内存释放的时间，但是会给开发人员带来**频繁申请和释放内存的管理负担**。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生**内存泄漏（没用的对象没被回收）**，垃圾对象永远无法被清除，随着系统运行时间的不断增长，**垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。**

在有了垃圾回收机制后，上述代码块极有可能变成这样：（pBridge交给Register自动管理）

![image-20200607135156739](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607135156739.png)

现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。



### Java的垃圾回收

自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险。

- 没有垃圾回收器，java也会和cpp样，各种悬垂指针，野指针，泄露问题让你头疼不已

自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发

对于Java开发人员而言，自动内存管理就像是一不黑匣子，如東过度依赖“自动”，那么这将会是一场灾难，最严重的就会**弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。**

此时，了解JM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见 OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题。

当需要排査各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。

![image-20200607135909271](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607135909271.png)

Java的垃圾回收分为 Minor GC、Major GC与Full GC（分代垃圾回收）

JVM 在进行 GC 时，并非每次都对上面三个内存区域一起回收的，**大部分时候回收的都是指新生代**

针对 HotSpot JVM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）

- 部分收集：**不是完整地收集整个Java堆的垃圾收集**。其中又分为：
  - 新生代收集（Minor gC/Young GC）：**只是新生代的垃圾收集**
  - 老年代收集（Major GC/Old GC）：**只是老年代的垃圾收集。**
    - 目前，只有 CMS GC会有单独收集老年代的行为。
    - **注意，很多时候 Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。**
  - 混合收集（Mixed GC）：收集**整个新生代**以及**部分老年代**的垃圾收集。
    - 目前，只有G1 GC会有这种行为。
- 整堆收集（Full GC）：收集==**整个java堆**==和==**方法区**==的垃圾收集。

**Minor GC**

**年轻代GC（Minor GC）触发机制：**

- 当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会引发GC。（每次 Minor GC会清理年轻代的内存。）
- 因为Java对象大多都具备朝生夕灭的特性，所以 Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解
- **Minor GC会引发==STW==，暂停其它用户的线程**，等垃圾回收结束，用户线程才恢复运行。（时间很短）



**Major GC/Full GC**

**老年代GC（Major GC） 触发机制:**

- 指发生在老年代的GC，对象从老年代消失时，我们说"Major GC"或"Full GC"发生了。

- 出现了 Major GC，经常会伴随至少一次的 Minor GC，但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行 Major GC的策略选择过程。

  - 也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足则触发 Major GC

- **Major GC的速度一般会比 Minor GC慢10倍以上，STW的时间更长。**

- 如果 Major GC后，内存还不足，就报OOM了。

  

**Full GC 触发机制**：

触发Full GC执行的情况有如下五种：

1. 调用 `System.gc()`时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过 Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

说明：**full gc是开发或调优中尽量要避免的。这样暂时时间会短一些**



垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。

- 其中，Java堆是垃圾收集器的工作重点。

从次数上讲

- 频繁收集 Young区
- 较少收集Old区
- 基本不动Perm区（或元空间）



## 垃圾回收算法

注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备

### 标记阶段（对象存活判断）

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先**需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。**只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。

那么在JVM中究竞是如何标记一个死亡对象呢？简单来说，**当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。**

**判断对象存活一般有两种方式：==引用计数算法==和==可达性分析算法==**



#### 引用计数法

引用计数算法（Reference Counting）比较简单，对**每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。**

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

**优点：**

- **实现简单，垃圾对象便于辨识：判定效率高，回收没有延迟性**

**缺点：**

- 它需要单独的字段存储计数器，这样的做法增加了**存储空间的开销**
- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了**时间开销**
- 引用计数器有一个严重的问题，即**==无法处理循环引用==**的情况。这是一条致命缺陷，导致在 **Java** 的垃圾回收器中**没有使用这类算法**

![image-20200607143851633](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607143851633.png)

引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制

具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。

Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。

Python如何解决循环引用？

- 手动解除：很好理解，就是在合适的时机，解除引用关系。
- 使用弱引用 weakref，weakref是 Python提供的标准库，旨在解决循环引用

#### 可达性分析（GC Roots）

相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地**解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。**

相较于引用计数算法，这里的可达性分析就是**Java**、C#选择的。这种类型的垃圾收集通常**也叫作追踪性垃圾收集**（Tracing Garbage Collection）

**所谓"GC Roots"根集合就是一组必须活跃的引用**

基本思路

- 可达性分析算法是**以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达**。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链**（Reference hain）
- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
- **在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象**

![image-20200607150821532](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607150821532.png)

在Java语言中，GC Roots包括以下几类元素

- **虚拟机栈中引用的对象**
  - 比如：各个线程被调用的方法中使用到的参数、局部变量等。
- **本地方法栈内JNI（通常说的本地方法）引用的对象**
- **方法区中类静态属性引用的对象**
  - 比如：Java类的引用类型静态变量
- **方法区中常量引用的对象**
  - 比如：字符串常量池（String Table）里的引用
- **所有被同步锁 synchronized持有的对象**
- **Java虚拟机内部的引用。**
  - 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器
- 反映java虛拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

![image-20200607152303234](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607152303234.png)

除了这些固定的 **GC Roots集合**以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象**“临时性”地加入（比如老年代持有新生代的引用，也可以作为GC  Roots的集合）**，共同构成完整 GC Roots集合。比如：分代收集和局部回收（Partial GC）。

- 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots集合中去考虑，才能保证可达性分析的准确性。

**小技巧：**由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。（比如栈的局部变量表的引用）

如果要使用可达性分析算法来判断内存是否可回收，那么**分析工作必须在一个能保障一致性的快照中进行**。这点不满足的话分析结果的准确性就无法保证。

**这点也是导致GC进行时必须 "Stop The world" 的一个重要原因**

- 即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。



#### 对象的finalization机制

Java语言提供了对象终止（finalization）机制来**允许开发人员==提供对象被销毁之前的自定义处理逻辑==**

当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize()方法。

finalize() 方法允许在子类中被重写，用于**在对象被回收时进行资源释放。**通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。

**永远不要主动调用某个对象的finalize()，不管重写没有，应该交给垃圾回收机制调用。**理由包括下面三点：

- **在 finalize() 时可能会导致对象复活**
-  **finalize()  方法的执行时机是没有保障的（调用了也是交给GC线程去执行）**，它完全由GC线程决定，极端情况下，若不发生GC，则finalize() 方法将没有执行机会。
- **一个糟糕的 finalize()  会严重影响GC的性能。（重写的烂）**

从功能上来说， finalize()  方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以 finalize()  方法在本质上不同于C++中的析构函数。



由于 finalize()  方法的存在，**虚拟机中的对象一般处于三种可能的状态：**

如果从所有的根节点都无法访间到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段**。一个无法触及的对象有可能在某一个条件下“复活”自己**，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：

- **可触及的：**从根节点开始，可以到达这个对象。
- **可复活的：**对象的所有引用都被释放，但是对象有可能在 finalize()  中复活。
- **不可触及的：**对象的 finalize()  被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 **finalize()  只会被调用一次。（免死金牌只能用一次）**

以上3种状态中，是由于  finalize()  方法的存在，进行的区分。只有在对象不可触及时才可以被回收。



#### 具体过程

引入finalization可以使对象复活的概念，则可达性分析下标记阶段的具体过程如下：

**判定一个对象objA是否可回收，至少要经历两次标记过程：**

1. 如果对象objA到 GC Roots没有引用链，则进行**第一次标记。**
2. 进行筛选，判断此对象是否有必要执行 finalize()  方法
   - 如果对象bjA没有重写 finalize()  方法，或者 finalize()  方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，ObjA被判定为不可触及的。
   - 如果对象objA重写了 finalize() 方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其 finalize() 方法执行。
   -  **finalize() 方法是对象逃脱死亡的最后机会**，稍后GC会对F-Queue队列中的对象进行**第二次标记。** **如果objA在 finalize() 方法中与引用链上的任何一个对象建立了联系那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下， finalize() 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize() 方法只会被调用一次**

![image-20200607164452662](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607164452662.png)

**测试对象复活**

```java
public class CanReliveObj {
    public static CanReliveObj obj;//类变量
    @Override
    protected void finalize() throws Throwable {
        System.out.println("调用当前类重写的finalize()方法");
        obj = this;		// 当前待回收的对象在finalize() 方法中与引用链上的一个对象obj建立了联系
    }

    public static void main(String[] args) {
        try {
            obj = new CanReliveObj();
            obj = null;
            // 对象第一次成功拯救自己
            System.gc();        // 调用垃圾回收器
            System.out.println("第一次GC");
            // 因为Finalizer线程优先级很低，暂停2秒，等待他先执行finalize()
            Thread.sleep(2000);
            if(obj == null){
                System.out.println("obj is dead");
            }else{
                System.out.println("obj is still alive");
            }
            System.out.println("第二次GC");
            obj = null;
            System.gc();
            Thread.sleep(2000);
            //下面这段代码与上面的完全相同，但是看到这次自救却失败了
            if(obj == null){
                System.out.println("obj is dead");
            }else{
                System.out.println("obj is still alive");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
```

不重写finalize()方法的结果

![image-20200607163554905](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607163554905.png)

重写finalize方法的结果，由于将一个类变量又再次指向了自己，该对象还是被引用的（静态变量obj），由于finalize只被调用一次，第二次gc直接就认为不可触及了

![image-20200607163715473](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607163715473.png)



#### MAT与JProfiler查看GC Roots

JVisualVM不是万能的，无法查看GC Roots相关的信息，所以需要借助别的工具，如MAT和JProfiler

**获取dump文件**

1、可以使用jmap命令生成离线的dump文件，具体后面再讲

2、使用JVisualVM导出

​	捕获的 heap dump文件是一个临时文件，关闭 VIsual1后自动删除，若要保留，需要将其另存为文件

- 可通过以下方法捕获 heap dump

  - 在左侧“Application"（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump （堆Dump）
  - 在 Monitor（监视）子标签页中点击 Heap Dump（堆Dump）按钮。

  本地应用程序的 Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。右击这个节点选择 save as（另存为）即可将 heap dump保存到本地。

3、通过JVM参数，在某些情景创建如果堆溢出时，记录dump文件

```
-XX:+HeapDumpOnOutOfMemoryError
```



**MAT**

MAT是 Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。

MAT是基于 Eclipse开发的，是一款免费的性能分析工具。(没 Eclipse打不开)

**JProfiler**

是一款非常强大的软件，可以查看GC Root和根据dump文件做OOM分析。

![image-20200607173122304](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607173122304.png)



### 清除阶段

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。
目前在JVM中比较常见的三种垃圾收集算法是**标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-**
**Compact**

#### 标记-清除算法

背景：

标记—清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。

**执行过程：**

当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 Stop The World），然后进行两项工作，第一项则是标记，第二项则是清除。

- **标记：**Collector从引用根节点开始遍历，**标记所有被引用的对象（非垃圾对象）**。一般是在对象的 Header中记录为可达对象
- **清除：**Collector对堆内存从头到尾进行线性的遍历（**遍历整个堆空间**），**如果发现某个对象在其 Header中没有标记为可达对象，则将其回收。**

![image-20200607174300415](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607174300415.png)

![image-20200607174447353](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607174447353.png)

**缺点**

- 效率不算高（两次大范围的遍历）
- **在进行GC的时候，需要停止整个应用程序**，导致用户体验差
- 这种方式清理出来的空闲内存是不连续的，产生**内存碎片**。需要维护一个空闲列表，即内存不规整需要记录那些空间被占用哪些没有被占用

**注意：何为清除**

这里所谓的潸除并不是真的置空，而是**把需要清除的对象地址保存在空闲的地址列表里**。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。（覆盖）



#### 复制算法

背景：

为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。

**核心思想：**

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

![image-20200607175644464](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607175644464.png)



**优点：**

- 没有标记和清除过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，**不会出现“碎片”问题**。

**缺点：**

- 此算法的缺点也是很明显的，就是**需要两倍的内存空间。**
- 对于G1这种分拆成为大量 region的GC，复制而不是移动，意味着GC需要维护 region之间对象引用关系（**维护复制过去的对象的引用关系**），不管是内存占用或者时间开销也不小。

**特别的**

- **如果系统中的垃圾对象很多，复制算法不会太理想**，复制算法应该用在需要复制的存活对象数量少的情况。



**应用场景**

在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。（如果使用在老年代，就基本会把大部分对象进行复制）

回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。



#### 标记-压缩算法（标记-整理算法）

背景：

**复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的**。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，**基于老年代垃圾回收的特性，需要使用其他的算法。**

**标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片（有足够空间但是因为碎片，大对象不能存入）**，所以JVM的设计者需要在此基础之上进行改进。**标记压缩（Mark-Compact）算法由此诞生。**

1970年前后，G.I.Steele、C.J.Chene和D.s.Wise等研究者发布标记压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。

**执行过程：**

- 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象

- 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间

  

![image-20200607183301635](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607183301635.png)



标记-压缩算法的最终效果等同于标记-淸除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法

二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。

可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

**优点：**

- **消除了标记-清除算法当中，内存区域分散的缺点**，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可
- **消除了复制算法当中，内存减半的高额代价**

**缺点：**

- 从**效率**上来说，标记-整理算法要**低**于复制算法。
- 移动对象的同时，如果对象被其他对象引用，则还需要**调整引用的地址**
- 移动过程中，需要全程暂停用户应用程序。即：STW



#### 总结

|          | Mark-Sweep         | Mark-Compact     | Copying                               |
| -------- | ------------------ | ---------------- | ------------------------------------- |
| 速度     | 中等               | 最慢             | 最快                                  |
| 空间开销 | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍大小（不堆积碎片） |
| 移动对象 | 否                 | 是               | 是                                    |

效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。

而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。



### 分代收集算法（广泛采用）

前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。

分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，**不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。**一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

Java程序运行的过程中，会产生大量的对象，其中有些对象是与==业务信息相关==，比如**Http请求中的 Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。**

==目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的。==

在 HotSpot中，基于分代的概念，Gc所使用的内存回收算法必须结合年轻代和老年代各自的特点

- 年轻代（Young Gen）

  年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。

  - **这种情况复制算法**的回收整理，**速度是最快的**。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 HotSpot中的两个 survivor的设计得到缓解。（survivor占用内存很小）

- 老年代（Tenured Gen）

  老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁

  这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由**标记-清除或者是标记-清除与标记整理的混合实现**。

  - Mark阶段的开销与存活对象的数量成正比。
  - Sweep阶段的开销与所管理区域的大小成正相关。
  - Compact阶段的开销与存活对象的数据成正比

以 HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的 Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent mode Failure时），将采用 Serial Old执行Full GC以达到对老年代内存的整理。

分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代



### 增量收集算法（从时间分配上减小STW的影响）

上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World的状态。在 Stop the World状态下，应用程序所有的线程都会挂起，暂停切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直按导致了增量收集（Incremental Collecting）算法的诞生。

**基本思想**

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，**那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程==只收集一小片区域==的内存空间，==接着切换==到应用程序线程。依次反复，直到垃圾收集完成。**

总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。増量收集算法通过**对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。**

**缺点：**

使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，**因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升**，造成**系统吞吐量的下降**



### 分区算法（从空间分配上减小STW的影响）

一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，**将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间**，从而减少一次GC所产生的停顿。

**分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间（region）。**

每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

![image-20200607192854973](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607192854973.png)



## 垃圾回收相关概念

### System.gc()理解

在默认情况下，通过 `System.gc()`或者 `Runtime.getRuntime().gc()`的调用，**会显式触发Full GC（提醒JVM进行一次垃圾回收）**，同时对老年代和新生代，方法区（很少）进行回收，尝试释放被丢弃对象占用的内存。（java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。唯一要能说有什么不同那就是在字节码层面上调用前者比调用后者短一点点，前者是1条字节码而后者是2条）

然而`System.gc()`调用附带一个免责声明，无法保证对垃圾收集器的调用。（只是提醒JVM进行一次垃圾回收，但是不确定何时执行）

而想要强制调用使用引用的对象的 finalize()方法，可以使用`System.runFinalization()`

JVM实现者可以通过 `System.gc()`调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在些特殊情况下，如我们正在编写一个性能基准（性能测试，保证每次环境一致或者尽可能让堆内存比较空），我们可以在运行之间调用`System.gc()`。

System.gc()的回收案例可以看宋红康老师的P156



### 内存溢出

内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一

由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况

大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。

**javadoc中对 OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。**



首先说没有空闲内存的情况：说明]ava虚拟机的堆内存不够。原因有二：

**（1）Java虚拟机的堆内存设置不够。**

比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms Xmx来调整。

**（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）**

对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关："java.lang.OutOfMemoryError:PermGen space"

随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了："java.lang.OutOfMemoryError:Metaspace"。直接内存不足，也会导致OOM。

这里面隐含着一层意思是，**在抛出 OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。**

- 例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等
- 在 Java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。

当然，也**不是在任何情况下垃圾收集器都会被触发的**

- 比如，我们去分配一个**超大对象**，类似一个超大数组超过堆的最大值，**JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出  OutOfMemoryError。**



### 内存泄漏

也称作“存储渗漏”。**严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。**

但实际情况很多时候一些不太好的实践（或疏忽）会**导致对象的生命周期变得很长甚至导致OOM（比如可以声明为局部引用变量的，声明成static类引用变量，大量这样的情况导致堆中可能很多都是长周期的对象，无法回收），也可以叫做宽泛意义上的“内存泄漏”**。

尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory异常，导致程序崩溃。

注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。

**严格意义上的例子：**

1. **单例**的生命周期和应用程序是一样长的，所以单例程序中，**如果持有对外部对象的引用的话**，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。

2. **一些提供 close的资源未关闭导致内存泄漏**

   数据库连接（dataSource.getConnection()），网络连接（socket）和io连接必须手动close，否则是不能被回收的。

![image-20200607204844804](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607204844804.png)



### STW(Stop the World)

Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。**停顿产生时整个应用程序其他线程都会被暂停，没有任何响应**，有点像卡死的感觉，这个停顿称为STW

- 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。
  - 分析工作必须在一个能确保**一致性的快照**中进行
  - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
  - **如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。**

被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。

- **STW事件和采用哪款GC无关，所有的GC都有这个事件。**
- 哪怕是G1也不能完全避免stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。
- **STW是JVM在后台自动发起和自动完成的**。在用户不可见的情况下，把用户正常的工作线程全部停掉
- 开发中不要用 System.gc(); 会导致stop-the-world的发生。



### 垃圾回收的并行和并发

并发：在操作系统中，是指**一个时间段**中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器（单核CPU）上运行。（感觉好像几个程序在同时执行，实际上某一时刻只有一个程序在占用cpu）

![image-20200607210904074](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607210904074.png)

并行：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。其实**决定并行的因素不是CPU的数量，而是CPU的核心数量**，比如一个CPU多个核也可以并行。

上面是操作系统层面的解释，接下来会介绍各种并行/并发的垃圾回收器，在此进行铺垫，并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：

- 并行（Parallel）：指**多条垃圾收集线程并行工作**，但此时用户线程仍处于等待状态
  - 如 ParNew、Parallel Scavenge、Parallel Old
- 串行（Serial）
  - 相较于并行的概念，单线程执行
  - 如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。

![image-20200607211530301](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607211530301.png)

- 并发（Concurrent）：指**一个时间段内用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）**，垃圾回收线程在执行时不会停顿用户程序的运行。（但不代表没有STW，发生STW用户线程也必须停止的）
  - 用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上
  - 如：CMS、G1

![image-20200607211853744](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607211853744.png)

### 安全点和安全区域

**安全点（类似游戏里的存档点，没到就不能执行某些操作）**

程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为**“安全点（Safepoint）”**

Safe point的选择很重要，**如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题**。大部分指令的执行时间都非常短暂，通常会根据**“是否具有让程序长时间执行的特征”为标准**。比如：**选择些执行时间较长的指令作为 Safe point**，如**方法调用、循环跳转和异常跳转等**

如何在GC发生时，检査所有线程都跑到最近的安全点停顿下来呢？

- 抢先式中断：（目前没有虚拟机采用了）

  首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。

- 主动式中断：

  设置一个中断标志，各个线程运行到 Safe point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。

**安全区域（相当于驿站）**

Safe point机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep状态或Blocked状态，这时候**线程无法响应JVM的中断请求**，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。

**安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。**我们也可以把 Safe Region看做是被扩展了的 Safepoint。

**实际执行：**

1、当线程运行到 Safe Region的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生GC，JVM会忽略标识为 Safe Region的线程状态

2、当线程即将离开 Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region的信号为止



### 引用(TODO)

我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。**为了方便垃圾回收**，在JDK1.2版之后，**Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft reference）、弱引用（Weak Reference）和虚引用（Phantom reference）4**种，==这4种引用强度依次逐渐减弱。==

除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们

![image-20200607214454645](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607214454645.png)

Reference子类中只有终结器引用（FinalReference）是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用。下面说到的回收都是默认在引用关系还在的情况下。

**强引用（StrongReference）**最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似	`Object obj= new Object();`这种引用关系。无论任何情况下，**只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。**（99%使用这种）

**软引用（SoftReference）**：**在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。**如果这次回收后还没有足够的内存，才会抛出内存溢出异常。（内存不足即回收）

**弱引用（WeakReference）**：被弱引用关联的对象只能生存到下一次垃圾收集之前。**当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。**（发生GC即回收）

**虚引用（PhantomReference）**：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。**为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。**



#### 强引用（不回收）

在]ava程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就**是我们最常见的普通对象引用，也是默认的引用类型。**

当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。如

```java
Object obj= new Object();
```

**强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。**

对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。

**相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，==强引用是造成Java内存泄漏的主要原因之一。==**

强引用例子：

![image-20200607220443533](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607220443533.png)

局部变量str指向 String Buffer实例所在堆空间，通过str可以操作该实例那么str就是 StringBuffer实例的强引用

对应内存结构：

![image-20200607220524798](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607220524798.png)

总结：

1. 强引用可以直接访问目标对象。
2. 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。
3. 强引用可能导致内存泄漏。

#### 软引用（内存不足就回收）

软引用是用来描述一些还有用，但非必需的对象。**只被软引用关联着的对象在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收（第一次回收是回收不可达的对象），**如果这次回收还没有足够的内存，才会抛出内存溢出异常。

**软引用通常用来实现内存敏感的缓存。**比如：**高速缓存就有用到软引用**。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference queue）。

类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。

在JDK1.2版之后提供了java.lang.ref.SoftReference类来实现软引用

案例：

```java
public class SoftReferenceTest {
    public static void main(String[] args) throws InterruptedException {
        SoftReferenceTest test = new SoftReferenceTest();  // 声明强引用
        SoftReference<Object> sf = new SoftReference<>(test);
        System.out.println(sf.get());
        test = null;             //销毁强引用
        System.gc();            // 由于内存足够，不会回收test原本引用的对象
        TimeUnit.SECONDS.sleep(5);  // 睡一下让GC先完成
        System.out.println(sf.get()); // test原本引用的对象，与前面的一致

    }
}
```

相当于内存足够的时候，堆空间的强引用和软引用不会被回收，当强引用转化为软引用（释放强引用设置为null，并建立了软引用SoftReference），软引用也会保证让这个对象不会被回收，当内存不足时，这个软引用的这个对象会被回收。



#### 弱引用（发生GC即回收）

弱引用也是用来描述那些非必需对象，**只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。**在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。

但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，**弱引用对象可以存在较长的时间。**

弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。

**软引用、弱引用都非常适合来保存那些可有可无的缓存数据。**如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。

在JDK1.2版之后提供了java.1ang.ref WeakReference类来实现弱引用

案例

```java
public class WeakReferenceTest {
    public static void main(String[] args) throws InterruptedException {
        WeakReferenceTest test = new WeakReferenceTest();
        WeakReference<WeakReferenceTest> wr = new WeakReference<>(test);
        
        System.out.println(wr.get());   //GC.Reference.WeakReferenceTest@74a14482
        test = null;        // 销毁强引用
        System.gc();
        
        TimeUnit.SECONDS.sleep(2);
        System.out.println(wr.get());   // null
    }
}
```

弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检査是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。

**你开发中使用过 WeakHashMap吗？**

查看源码发现，里面静态内部类的Entry是弱引用的，发生GC就释放，尽可能的避免了OOM

```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> 
```



#### 虚引用（跟踪回收对象）

也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个

**一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。**

它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。

为一个对象设置虚引用关联的**唯一目的在于跟踪垃圾回收过程**。比如：能在这个对象被收集器回收时收到一个系统通知。

**虚引用必须和引用队列一起使用。**虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。

**由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。**

在JDK1.2版之后提供了 PhantomReference类来实现虚引用。

示例：

```java
public class PhantomReferenceTest {
    public static void main(String[] args) throws InterruptedException {
        PhantomReferenceTest test = new PhantomReferenceTest();
        ReferenceQueue<PhantomReferenceTest> queue = new ReferenceQueue<>();    // 引用队列
        PhantomReference pr = new PhantomReference(test,queue);
        System.out.println(pr);                     //java.lang.ref.PhantomReference@74a14482

        System.out.println(pr.get());               // null
        System.out.println(queue.poll());           // 此时队为空,null
        test = null;
        System.gc();            // 一旦回收test，就会把虚引用pr指向的对象放到引用队列中去
        TimeUnit.SECONDS.sleep(2);
        System.out.println(queue.poll());       //java.lang.ref.PhantomReference@74a14482

    }
}
```

注意其实虚引用和对象之间基本没有任何关系，相当于一个监视器，当对象被回收的时候，就会把虚引用指向的对象放到引用队列里面去。



#### 终结器引用（了解一下即可）

它用以实现对象的finalize()方法，也可以称为终结器引用

无需手动编码，其内部配合引用队列使用

在GC时，终结器引用入队。由 finalizer线程通过终结器引用找到被引用对象并调用它的finalize() 方法，第二次GC时才能回收被引用对象。



## 垃圾回收器（TODO）

垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。

由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衔生了众多的GC版本。

从不同角度分析垃圾收集器，可以将GC分为不同的类型。

**分类：**

- 按**线程数（垃圾回收线程）**分，可以分为串行垃圾回收器和并行垃圾回收器。（发生GC触发STW，区别是GC是多个线程还是单个线程执行）

  ![image-20200607233341024](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607233341024.png)

  - 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。
    - 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。**所以，串行回收默认被应用在客户端的 Client模式下的JVM中**
    - 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。
  - 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。

- 按照**工作模式**分，可以分为并发式垃圾回收器和独占式垃圾回收器

  ![image-20200607211853744](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200607211853744.png)

  - 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。
  - 独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。

- 按**碎片处理**方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器
  - 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。（指针碰撞）
  - 非压缩式的垃圾回收器不进行这步操作。（空闲列表）
- 按**工作的内存区间**分，又可分为年轻代垃圾回收器和老年代垃圾回收器。

**评估性能指标**

- **吞吐量：运行用户代码的时间占总运行时间的比例**
  - （总运行时间：程序的运行时间+内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。（1-吞吐量）
- **暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。**
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- **内存占用：Java堆区所占的内存大小。**
- 快速：一个对象从诞生到被回收所经历的时间。

这三加粗的共同构成一个“不可能三角“，三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。

这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。（一次垃圾回收耗时更多了）

**简单来说，主要抓住两点：**

- **吞吐量**
- **暂停时间**

### 性能指标

#### 吞吐量

吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）

比如。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

这种情况下，**应用程序能容忍较高的暂停时间（一定条件下，暂停时间越长也变相说明了一次运行时间也越长，只要我占比高，一样吞吐量大）**，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。

吞吐量优先，要做到暂停时间占比例最小即可，(6-0.4)/6，如下图所示:

![image-20200608004530927](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608004530927.png)

#### 暂停时间

暂停时间是指一个时间段内应用程序线程暂停，让GC线程执行的状态

- 例如，GC期间188毫秒的暂停时间意味着在这188毫秒期间内没有应用程序线程是活动的。

暂停时间优先，意味着尽可能让**单次STW的时间最短**：0.1+0.1+0.1+0.1+0.1=0.5（但总体会更长）

![image-20200608105316293](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608105316293.png)

高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越。

低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的2θθ毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。

不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。

- 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收相反的
- 如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。

现行标准：**在最大吞吐量优先的情况下，降低停顿时间。（不同回收器，也可能更是在规定停顿时间内，提高吞吐量）**



### 概述

垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。

那么，Java常见的垃圾收集器有哪些？

有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。

- 1999年随JDK1.3.1—起来的是串行方式的 Serial GC，它是第一款GC。ParNew垃圾收集器是 Serial收集器的多线程版本
- 2002年2月26日，Parallel GC和 Concurrent Mark Sweep GC跟随JDK1.4.2起发布**Parallel GC在JDK6之后成为 Hot spot默认GC。**
- 2012年，在JDK1.7u4版本中，G1可用。
- 2017年，**JDK9中G1变成默认的垃圾收集器**，以替代CMS
- 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟
- 2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为"No-Op（无操作）"回收器。同时，**引入ZGC**：可伸缩的低延迟垃圾回收器（Experimental）。
- 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah gc：低停顿时间的GC（Experimental）
- 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统
- 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在 macos和Windows上的应用

**分类**

按串行、并行、并发划分：

- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：CMS、G1

![image-20200608130450377](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608130450377.png)

按分代收集划分：

- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：SerialOld、ParallelOld、CMS；
- 整堆收集器：G1

![image-20200608113512999](H:\Desktop\新建文件夹\Blog\docs\backend\java高级知识\JVM\pictures\image-20200608113512999.png)

黑色实线：最新的组合关系 JDK14

1、Serial + Serial Old 

2、Parallel Scavenge + Parallel Old

3、ParNew + CMS（其中，Serial Old作为CMS出现"Concurrent Mode Failure"失败的后备预案）

红色虚线：由于维护和兼容性测试的成本，在JDK8时将 Serial + CMS、ParNew+ Serial Old 这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。

绿色虚线：]DK14中：弃用Parallel Scavenge和  Serial Old 组合（JEP366）

青色虚线：JDK14中：删除CMS垃圾回收器（JEP363）

题外话：CMS GC和Parallel Scavenge不能一起使用的原因是底层结构不同，导致不兼容（因此Parallel一般只自己玩）

为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。

虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器

### 查看默认的垃圾收集器

1、在idea的vm option加

```
-XX:+PrintCommandLineFlags
```

2、或者在cmd

```
java -XX:+PrintCommandLineFlags -version
```



### Serial回收器（串行回收）

Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。

Serial 收集器作为 Hotspot中 Client模式下的默认新生代垃圾收集器。

Serial 收集器**采用==复制算法==、串行回收**和"**"Stop-the-World"机制**的方式执行内存回收。

除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的Serial Old收集器。

**Serial Old收集器同样也采用了串行回收和"Stop-the-World"机制，只不过内存回收算法使用的是==标记-压缩算法==**

- Serial Old是运行在Client模式下默认的老年代的垃圾回收器
- **Serial Old在 Server模式**下主要有两个用途：
  - 与新生代的Parallel Scavenge配合使用
  - 作为老年代CMS收集器的后备垃圾收集方案

这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。

![image-20200608175143985](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608175143985.png)



优势：**简单而高效**（与其他收集器的单线程比），**对于限定单个CPU的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。**

- 运行在 Client模式下的虚拟机是个不错的选择。

在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。

在 Hotspot虚拟机中，使用`-XX:+UseSerialGC`参数可以指定年轻代和老年代都使用串行收集器。

```
-XX:+UseSerialGC
```

- 等价于新生代用 Serial GC，且老年代用 Serial Old GC

总结：

这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。

**对于交互较强的应用而言，这种垃圾收集器是不能接受的**。一般在Java web应用程序中是不会采用串行垃圾收集器的。



### ParNew回收器（并行回收）

如果说 Serial GC是年轻代中的单线程垃圾收集器，那么 ParNew收集器则是 Serial 收集器的多线程版本。

- Par是Parallel 的缩写，New：只能处理的是新生代

ParNew收集器除了采用**并行回收（多个垃圾线程）**的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用**复制算法**、**"Stop-the-World"机制**

ParNew是很多JVM运行在 Server模式下**新生代**的默认垃圾收集器。

下图是ParNew与SerialOld 联合使用

![image-20200608180350050](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608180350050.png)

- 对于**新生代，回收次数频繁，使用并行方式高效**

- 对于**老年代，回收次数少，使用串行方式节省资源。**（CPU并行需要切换线程，串行可以省去切换线程的资源）

由于 ParNew收集器是基于并行回收，那么是否可以断定 ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？

- ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量
- **但是在单个CPU的环境下**，ParNew收集器不比 Serial收集器更高效。虽然 **Serial 收集器是基于串行回收**，但是由于CPU**不需要频繁地做任务切换**，因此可以有效避免多线程交互过程中产生的一些额外开销

因为除 Serial外，目前只有 ParNew GC能与CMS收集器配合工作

在程序中，开发人员可以通过选项-XX:+UseParNewGC"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。

-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数。

```bash
-XX:+UseParNewGC	# 使用ParNew
-XX:ParallelGCThreads	# 限制线程数量
```



### Parallel Scavenge回收器（并行，吞吐量优先）

HotSpot的年轻代中除了拥有 ParDew收集器是基于并行回收的以外，**Parallel Scavenge收集器同样也采用了复制算法、并行回收和"Stop the World"机制。**

那么Parallel收集器的出现是否多此一举？

- 和 ParNew收集器不同，Parallel Scavenge收集器的目标则是达到个**可控制的吞吐量（Throughput）**，它也被称为**吞吐量优先的垃圾收集器**。

- **自适应调节策略**也是Parallel Scavenge与 ParNew一个重要区别。

高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算仼务，**主要适合在后台运算而不需要太多交互的任务**。因此，常见在服务器环境中使用。例如，那些**执行批量处理、订单处理、工资支付、科学计算的应用程序。**

Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的**Parallel Old收集器**，用来代替老年代的 Serial Old收集器。

Parallel Old收集器采用了**标记-压缩算法**，但同样**也是基于并行回收和”Stop-the-World"机制。**

![image-20200608200144334](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608200144334.png)

- 在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel Old收集器的组合，在 Server模式下的内存回收性能很不错。
- **在Java8中，默认是此垃圾收集器。**

参数：

1、手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。

```bash
-XX:+UseParallelGC  # 年轻代使用 Parallel 
```

2、手动指定老年代都是使用并行回收收集器。**这两个参数，默认开启一个，另一个也会被开启。**（互相激活）

```bash
-XX:+UseParallelOldGC # 老年代使用 ParallelOld 
```

3、设置**年轻代并行收集器的线程数**。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。（太多会导致线程切换，恢复线程上下文耗时）

- 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
- 当cPU数量大于8个，ParallelGCThreads的值等于 3+[5+ CPU Count]/8]。

```bash
-XX:ParallelGCThreads	# 限制线程数量
```

4、设置垃圾收集器最大停顿时间即STW的时间。单位是毫秒。

- 为了尽可能地把停顿时间控制在 MaxGCPauseMillis以内，收集器在工作时会调整 Java堆大小或者其他一些参数。(设置GC时间小，可能堆就小，同样的业务代码，发生GC的频率就高)
- 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。
- 该参数使用需谨慎。

```bash
-XX:MaxGCPauseMillis # 设置垃圾收集器最大停顿时间
```

5、垃圾收集时间占总时间的比例，用于衡量吞吐量大小（垃圾回收占用比例= 1 / (N+1)，其中N是自己设置的值，如设置99，则1%的时间用于垃圾回收）

- 取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1%
- 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越短，Ratio参数就容易超过设定的比例。

```bash
-XX:GCTimeRatio
```

6、设置自适应调节策略（默认开启）

我们之前看到Eden:S0:S1可能不是8:1:1，就是因为开启了自适应调节，关闭了自适应调节也不好使，必须手动设置SurvivorRatio

- 在这种模式下，**年轻代的大小、Eden和 Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。**
- 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间
  （MaxGCPauseMillis），让虚拟机自己完成调优工作。

```bash
-XX:+UseAdaptiveSizePolicy   # 设置Parallel Scavenge收集器开启自适应调节
```



### CMS回收器（并发，低延时）

在JDK1.5时期，Hotspot推出了一款在**强交互应用**中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 Hotspot 虚拟机中第一款真正意义上的**并发收集器**，它第一次实现了**让垃圾收集线程与用户线程同时工作。**

CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。

- **目前很大一部分的 Java 应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，**以给用户带来较好的体验CMS收集器就非常符合这类应用的需求

CMS的垃圾收集算法采用==**标记-清除算法**==，并且**也会"Stop-the-World"**

不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMs来收集老年代的时候，新生代只能选择 ParNew或者 Serial收集器中的一个。

在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC(JDK14删除)

![image-20200608205328112](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608205328112.png)

CMS整个过程比之前的收集器要复杂，**整个过程分为4个要阶段，即初始标记阶段(STW)、并发标记阶段、重新标记阶段(STW)和并发清除阶段。（实际步骤很复杂，以下为粗略版，日后补充）**

- 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为**"Stop-the-World"** 机制而出现短暂的暂停，这个阶段的主要任务**仅仅只是标记出GC Roots能==直接关联==到的对象。**一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的**速度非常快。**（STW）
- 并发标记（Concurrent-Mark）阶段：**从 GC Roots的==直接关联对象开始遍历整个对象图==的过程**，这个过程耗**时较长但是不需要停顿用户线程**，可以与垃圾收集线程一起并发运行。
- 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此**为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。（并发怀疑是垃圾，进行确认，STW）
- 并发清除（Concurrent-Sweep）阶段：此阶段**清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。**由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。（碎片问题）



尽管CMs收集器采用的是并发回收（非独占式），但是在其**初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制**暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the word”，只是尽可能地缩短暂停时间。

**由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。**

另外，由于在垃圾收集阶段用户线程没有中断，所以**在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。**因此，CMs收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是**当堆内存使用率达到某一阈值时，便开始进行回收，**以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是**CMS运行期间预留的内存无法满足程序需要**，就会出现一次**"Concurrent Mode Failure"失败**，这时虚拟机将启动**后备预案：临时启用 Serial Od收集器来重新进行老年代**的垃圾收集，这样停顿时间就很长了。（串行）

CMS收集器的垃圾收集算法采用的是**标记-清除算法**，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将**会产生一些内存碎片**。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free list）执行内存分配。

![image-20200608212142180](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200608212142180.png)



**有人会觉得既然 Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？**

答案其实很简单，因为当并发清除的时候，用 Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合"Stop the World"这种场景下使用（停止用户线程，再修改对象地址）

**CMS的优点**

- 并发收集
- 低延迟

**CMS的缺点（内存碎片是致命缺点）**

- **会产生内存碎片**，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。（业务高峰期，碎片很多会很致命）
- **CMS收集器对cpu资源非常敏感。**在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。（本来CPU所有线程专注的做用户的事，现在还要分几个线程给CMS）
- **CMS收集器无法处理浮动垃圾。**可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么**在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收（就是本身不是垃圾，但是并发的用户线程执行过程中，将其引用失效，那么这些对象相当于浮动垃圾，此次GC是无法回收的）**，从而只能在**下一次执行GC时释放**这些之前未被回收的内存空间。

CMS 触发时机 ：可以查阅 [JVM 源码解读之 CMS GC 触发条件](https://mp.weixin.qq.com/s?__biz=MzUyMDE1ODQ3NQ==&mid=2247483851&idx=1&sn=8cb444039449848531b7ca72c396e07e&chksm=f9efedafce9864b9dbb645863d7d3c8b34e83888d07e175dd9c931576db2ecc0aa90835fcf50&scene=21#wechat_redirect)

**CMS Full GC时机（对象往老年代存，但是不够空间）**

- 大对象分配到老年代时，可用空间不足
- perm或metaspace空间不足 （JDK 8 开始HotSpot取消了perm，将类信息存放在metaspace中）
- 晋升失败：年轻代的存活对象，需要迁移到老年代时，老年代剩余对象不足
- promotion failed：担保失败，，gc日志会记录信息（如：[ParNew (promotion failed): 1669947K->145784K(1887488K)）；
- concurrent mode failure：执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，或者在做Minor GC的时候，新生代Survivor空间放不下，需要放入老年代，而老年代也放不下而产生的，gc日志会记录信息（如：(concurrent mode failure): 2902473K->1221894K(3354624K), 0.3778980 secs] ）

参数：

1、手动指定老年代使用CMS收集器执行内存回收任务。会自动的将`-XX:+UseParNewGC`打开。即ParNew（Young区）+CMS+Serial Old（Old区）会联合使用

```bash
-XX:+UseConcMarkSweepGC
```

2、设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。（由于回收和用户线程是并发的，不能等到不够用了才回收）

- JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。**JDK6及以上版本默认值为92%**
- 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，先触发CMS回收器，以避免老年代内存不够用而频繁触发Full GC，导致启动老年代Serial收集器收集垃圾。**因此通过该选项便可以有效降低Full GC的执行次数。（其实 CMS GC 的触发条件非常多，不只是 CMSInitiatingOccupancyFraction 阈值触发这么简单。）**

```bash
-XX:CMSInitiatingOccupanyFraction
```

3、用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。

```bash
-XX:+UseCMSCompactAtFullCollection
```

4、设置在执行多少次 Full GC内存空间进行压缩整理。（Full GC也有分Sweep策略和Compact策略，后面再研究清楚）

```bash
-XX:CMSFullGCsBeforeCompaction
```

5、设置CMS的线程数量。

- CMS默认启动的线程数是（ParallelGCThreads+3）/4，ParalleGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟

```bash
-XX:ParallelCMSThreads
```

JDK9新特性：CMS被标记为 Deprecate了（JEP291）

如果对]DK9及以上版本的 Hotspot虚拟机使用参数-`XX:UseConcMarkSweepGC`来开启CMs收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。

JDK14新特性：删除CMS垃圾回收器（JEP363）
移除了CMS垃圾收集器，如果在JK14中使用`-XX:+UseConcMarkSweepGC`的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM

小结：

HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？

请记住以下口令

如果你想要最小化地使用内存和并行开销，请选 Serial gc；

如果你想要最大化应用程序的吞吐量，请选Parallel GC；

如果你想要最小化GC的中断或停顿时间，请选 CMS GC。



### G1回收器（区域化分代式）

**既然我们已经有了前面几个强大的Gc，为什么还要发明 Garbage First（G1）GC？**

原因就在于应用程序所应对的**业务越来越庞大、复杂，用户越来越多**，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GCc进行优化。G1（Garbage-First）垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。

与此同时，为了适应现在不断扩大的内存和**不断增加的处理器数量**，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。

**官方给G1设定的目标是==在延迟可控的情况下获得尽可能高的吞吐量==，所以才担当起“全功能收集器”的重任与期望**

**为什么名字叫做 Garbage First（G1）呢？**

因为G1是一个并行回收器，它**把堆内存分割为很多不相关的区域（Region）**（物理上不连续的）。使用不同的 Region来表示Eden、幸存者0区，幸存者1区，老年代等。

G1 GC有计划地**避免在整个Java堆中进行全区域的垃圾收集**。G1跟踪各个 Region里面的垃圾堆积的**价值大小（回收所获得的空间大小以及回收所需时间的有利程度）**，在后台维护一个优先列表，每次根据允许的收集时间，**优先回收价值最大的 Region。**

**由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：==垃圾优先（Garbage First）==。**

G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对**配备多核CPU及大容量内存的机器**，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。

在JDK1.7版本正式启用，移除了 Experimental的标识，是**JDK9以后的默认垃圾回收器**，取代了CMS回收器以及Parallel+Parallel Old组合被oracle官方称为**“全功能的垃圾收集器”**。

与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用`-XX:+UseG1GC`来启用。

与其他GC收集器相比，**G1使用了全新的分区算法**，其特点如下所示：

![image-20200609014620098](H:\Desktop\新建文件夹\Blog\docs\backend\java高级知识\JVM\pictures\image-20200609014620098.png)

- **并行与并发**

  - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
  - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

- **分代收集**

  - 从分代上看，**G1依然属于分代型垃圾回收器**，它会区分年轻代和老年代，年轻代依然有Eden区和 Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量

  - 将**堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。（新增Humongous区，主要存储大对象）**

  - 和之前的各类回收器不同，它**同时兼顾年轻代和老年代**。对比其他回收器，或者工作在年轻代，或者工作在老年代；

    ![image-20200609023332268](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609023332268.png)

- **空间整合**
  - CMS:“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理
  - G1将内存划分为一个个的 Region。内存的回收是以 region 作为基本单位的。
    **Region之间是复制算法**，但整体上实际可看作是**标记-压缩（Mark-Compact）**算法，两种算法都可以**避免内存碎片**。这种特性有利于程序长时间运行，**分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC**。尤其是当Java堆非常大的时候，G1的优势更加明显。

- **可预测的停顿时间模型（即：软实时 soft real-time）**

  这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

  - 由于分区的原因，G1可以**只选取部分区域进行内存回收**，这样缩小了回收的范围，因此对于**全局停顿情况的发生也能得到较好的控制。**
  - G1跟踪各个 Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台**维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region**。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
  - 相比于CMS GC，G1未必能做到CMS 在最好情况下的延时停顿，但是最差情况要好很多。

**缺点：**

相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。(需要一些辅助结构如Rset，要占用更多空间)

从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间，高于此内存大小，G1表现更加优秀。

**参数：**

1、手动指定使用G1收集器执行内存回收任务。（JDK 9 之后是默认的）

```bash
-XX:+UseG1GC
```

2、设置每个 Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的 Java 堆大小划分出约2048个区域（Region）。如1MB，则需要堆大小为2G。

默认是堆内存的1/2000。

```bash
-XX:G1HeapRegionSize
```

3、设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms

```bash
-XX:MaxGCPauseMillis
```

4、设置STW工作线程数的值。最多设置为8

```bash
-XX:ParallelGCThread
```

5、设置并发标记的线程数。将n设置为并行垃圾回收线程数（上面设置STW工作线程数的值Parallel GCThreads）的1/4左右。

```bash
-XX:ConcGCThreads
```

6、设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45

```bash
-XX:InitiatingHeapOccupancyPercent
```



**使用G1回收器的常见操作步骤:**

G1的设计原则就是简化JVW性能调优，开发人员只需要简单的三步即可完成调优：

- 第一步：开启G1垃圾收集器
- 第二步：设置堆的最大内存
- 第三步：设置最大的停顿时间

G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。



**G1回收器使用场景：**

面向服务端应用。针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）

最主要的应用是**需要低GC延迟，并具有大堆**的应用程序提供解决方案；

- 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的 Region的增量式清理来保证每次GC停顿时间不会过长）。

用来替换掉JDK1.5中的CMS收集器，在下面的情况时，使用G1可能比CMS好

- 超过50%的Java堆被活动数据占用
- 对象分配频率或年代提升频率变化很大(新生代频繁晋升)
- GC停顿时间过长（长于0.5至1秒）。

Hotspot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的 JVM 线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即**当 JVM 的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。**



**分区Region（从正面战争到打游击）**

使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立 Region块，每个 Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过`-XX:G1HeapRegionSize`设定。**所有的 Region大小相同，且在JVM生命周期内不会被改变。**

虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region的动态分配方式实现逻辑上的连续。

![image-20200609023423042](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609023423042.png)

一个 region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是**一个 region当前只可能属于一个角色**。图中的E表示该 region属手Edeh内存区域，s表示属于 Survivor内存区域，o表示属于old内存区域。图中空白的表示未使用的内存空间

G1垃圾收集器还增加了一种新的内存区域，叫做 Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个 region，就放到H。

设置H的原因：

对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个**短期存在的大对象**，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个 Humongous区它用来专门存放大对象。**如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。**为了能找到连续的H区，有时候不得不启动Fu11GC。G1的大多数行为都把H区作为老年代的一部分来看待

实际上，指针碰撞和TLAB的设计依旧存在在Region上



**Remembered Set（记忆集）**

- 一个对象被不同区域引用的问题，如果Eden里的对象，被Old区的对象引用，那么回收新生代也不得不同时扫描老年代？

  这样的话会降低 Minor gC的效率，于是提出了Remembered Set

![image-20200609040442672](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609040442672.png)

解决方法

无论G1还是其他分代收集器，JVM都是使用 Remembered set来避免全局扫描：(GC Roots的概念放大，Old引用可能算在GC Roots Set里面)

- **每个 Region都有一个对应的 Remembered Set**
- 每次 Reference类型数据写操作时，都会产生一个 Write barrier（写屏障）暂时中断操作
- 然后检查将要写入的引用指向的对象是否和该 Reference类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；
- 如果不同，通过 CardTable把相关引用信息记录到引用指向对象的所在 Region对应的Remembered set中；
- 当进行垃圾收集时，在GC根节点的枚举范围加入 Remembered set；就可以保证不进行全局扫描，也不会有遗漏。

![image-20200609041115445](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609041115445.png)



**G1 GC的垃圾回收过程主要包括如下三个环节：**

- **年轻代GC（Young GC）**：实际上三个环节都在发生Young GC
- **老年代并发标记过程（Concurrent Marking）**
- **混合回收（Mixed GC）**(Young GC + Old GC)
- 如果需要，单线程、独占式、高强度的Full GC还是继续存在的（一般不会）。它针对GC的评估失败提供了一种失败保护机制，即强力回收。

![image-20200609032429964](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609032429964.png)

顺时针，young gc-> young gc + concurrent mark-> Mixed GC顺序，进行垃圾回收

应用程序分配内存，**当年轻代的Eden区用尽时开始年轻代回收过程**；G1的年轻代收集阶段是一个**并行的独占式（STW）**收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后**从年轻代区间移动存活对象到 Survivor区间或者老年区间，也有可能是两个区间都会涉及。**

**当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。**

**标记完成马上开始混合回收过程。**对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，**G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收小部分老年代的 Region就可以了（价值比较高的Region）。**同时，这个老年代 Region是和年轻代一起被回收的。

举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约1G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。

**1、年轻代GC：**

JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，**当Eden空间耗尽时**，G1会启动一次年轻代垃圾回收过程。

**年轻代垃圾回收只会回收Eden区和 Survivor区。**

YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和 Survivor区所有的内存分段。



![image-20200609122515665](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609122515665.png)

<div style="text-align:center;color:#C0C0CE;">上面为YGC前，下面为YGC后</div>

回收过程如下

- **第一阶段，扫描根。**

  根是指 static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同Rset记录的外部引用作为扫描存活对象的入口。

- **第二阶段，更新Rset**

  处理 dirty card queue（见下文）中的card，更新Rset。此阶段完成后，Rset可以准确的反映老年代对所在的内存分段中对象的引用。

  对于应用程序的引赋值语句 object.field= object，JVM会在之前和之后执行待殊的操作以在 dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对 Dirty Card Queue中所有的card进行处理更新RSet，保证RSet实时准确的反映引用关系。

  那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。

- **第三阶段，处理Rset。**

  识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。

- **第四阶段，复制对象（复制算法）**

  此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到 Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阈值会被会被复制到old区中空的内存分段。如果 Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。

- **第五阶段，处理引用。**

  处理Soft，Weak，Phantom，Final，JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。

**2、并发标记阶段（跟CMS很像）**

- **1.初始标记阶段：**标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。
- **2.根区域扫描（Root Region Scanning）**：G1 GC扫描 Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 young GC之前完成。
- **3.并发标记（Concurrent Marking）**：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 young GC中断。在并发标记阶段，**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。**同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
- **4.再次标记（Remark）**：由于应用程序持续进行，需要修正上一次的标记结果。是sTW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。
- **5.独占清理（cleanup，STW）**：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STw的。
  这个阶段并不会实际上去做垃圾的收集
- **6.并发清理阶段：**识别并清理完全空闲的区域。

**3、混合回收（回收Young和Old，其中Old区的回收根据并发标记的结果确定）**

当越来越多的对象晋升到老年代Old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个Old GC，除了回收整个 Young Region，还会回收一部分的 Old region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC并不是Full GC。

![image-20200609125223992](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609125223992.png)

- 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过`-XX:G1MixedGCCountTarget`设置）被回收。
- 混合回收的回收集（collection set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样（复制算法），只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程
- 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。**垃圾占内存分段比例越高的，越会被先回收**。并且有一个阈值会决定内存分段是否被回收`-XX:G1MixedGCLiveThresholdPercent`，默认为65%，意思是**垃圾占内存分段比例要达到65%才会被回收**。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。
- 混合回收并不一定要进行8次。有一个阈值`-XX:G1 HeapWastePercent`，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。

**4、可能的Full GC**

G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。

要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。

导致G1 Full GC的原因可能有两个

1. Evacuation（回收阶段）的时候没有足够的to-space来存放晋升的对象
2. 并发处理过程完成之前空间耗尽

从 Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。（即G1的Young GC是STW的，目的是最大幅度提高垃圾收集效率）

G1 回收器优化建议

- 不要调整年轻代大小
  - 避免使用`-Xmn`或`-XX:NewRatio`等相关选项显式设置年轻代大小固定年轻代的大小会覆盖暂停时间目标
- 暂停时间目标不要太过严苛
  - G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间
  - 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。

### 7种垃圾回收器总结

截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不冋的垃圾收集器。

![image-20200609173427086](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609173427086.png)

GC发展阶段：

Serial => parallel（并行）=>CMS（并发）=>G1=>ZGC

Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。

怎么选择垃圾收集器？

1. 优先调整堆的大小让JVM自适应完成。

2. 如果内存小于100M，使用串行收集器

3. 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器

4. 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择

5. 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器

   官方推荐G1，性能高。**现在互联网的项目，基本都是使用G1**

最后需要明确一个观点：

- 没有最好的收集器，更没有万能的收集；
- 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器

### GC日志分析

通过阅读GC日志，我们可以了解]ava虚拟机内存分配与回收策略。

**内存分配与垃圾回收的参数列表**

```bash
-XX:+PrintGC  				# 输出GC日志。类似：-verbose:gc
-XX:+PrintGCDetai1s		    # 输出Gc的详细日志
-XX:+PrintGCTimeStamps      # 输出Gc的时间戳（以基准时间的形式）
-xx:+ PrintGcDatestamps     # 输出Gc的时间戳（以日期的形式，如2013-0504T21：53：59.234+0800）
-XX:+PrintHeapAtGC          # 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log      # 日志文件的输出路径
```

![image-20200609175841130](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609175841130.png)

补充说明

![image-20200609180241977](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609180241977.png)

![image-20200609180406333](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609180406333.png)



日志各字段规律如下

![image-20200609180612412](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609180612412.png)

**Minor GC 日志**

具体如下

![image-20200609180657418](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609180657418.png)

**Full GC 日志**

![image-20200609181052068](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609181052068.png)

OK是指占用为0



日志分析工具

上面说到可以把日志持久化保存下来

```bash
-Xloggc:../logs/gc.log      # 日志文件的输出路径
```

我们可以用一些工具去分析这些gc日志

常用的日志分析工具有：GCViewer（下载github的jar包）、GREasy（在线解析，功能更强些）、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。



### 扩展：ZGC回收器

`-XX:UseZGC`

ZGC回收器的目标，**在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把圾收集的停顿时间限制在十毫秒以内的低延迟。**

《深入理解Java虚拟机》一书中这样定义ZGC:ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现**可并发的标记-压缩算法的，以低延迟为首要目标**的一款垃圾收集器。

ZGC的工作过程可以分为4个阶段：**并发标记->并发预备重分配->并发重分配->并发重映射等。**

ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。

ZGC的提出是具有革命性的，与G1和Paraller 对比测试数据：

![image-20200609194219774](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609194219774.png)

![image-20200609194248127](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200609194248127.png)

## 面试题

- 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和g1
- JVM GC算法有哪些，目前的JDK版本采用什么回收算法，各有什么优缺点
- G1回收器讲下回收过程
- GC是什么？为什么要有GC？
- GC的两种判定方法？CMS收集器与G1收集器的特点。
- 说一下GC算法，分代回收说下
- 垃圾收集策略和算法
- JVM GC原理，JVM怎么回收内存
- CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？
- java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的
- 什么情况下触发垃圾回收？
- 如何选择合适的垃圾收集算法？
- System.gc() 和 runtime.gc() 会做什么事情？
- 强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？

- CMS回收停顿了几次，为什么要停顿两次。

