## JVM运行和类加载
### 类加载机制
JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成JVM可以直接使用的Java类型的过程。
* 加载
将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。这个过程需要类加载器参与。
* 链接
将Java类的二进制代码合并到JVM的运行状态之中的过程
    * 验证：
确保加载的类信息符合JVM规范，没有安全方面的问题。
    * 准备：
正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配
    * 解折
虚拟机常量池内的符号引用替换为直接引用的过程

* 初始化
    * 初始化阶段是执行类构造器\<clinit>()方法的过程。类构造器\<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。
    * 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化
   * 虚拟机会保证一个类的\<clinit>()方法在多线程环境中被正确加锁和同步。
    * 当访问一个Java类的静态域时，只有真正声明这个域的类才会被初始化。

![image-20200426032149469](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200426032149469.png)

* 类的主动引用（一定会发生类的初始化）
    * new一个类的对象
    * 调用类的静态成员（除了final常量）和静态方法
    * 使用java.lang.reflect包的方法对类进行反射调用
    * 当虚拟机启动，java Hello，则一定会初始化Hello类，说白了就是先启动main方法所在的类
    * 当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类
* 类的被动引用（不会发生类的初始化）
    * 当访问一个静态域时，只有真正声明这个域的类才会被初始化
        * 通过子类引用父类的静态变量，不会导致子类初始化（父类会初始化）
    * 通过数组定义类引用，不会触发此类的初始化
    ```java
    //A对象数组
        A[] as = new A[10];

    ```
    * 引用常量(final)不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）


### 类加载器
* 引导类加载器（bootstrap class loader）(用c写的，其他均为java,为扩展类加载器父类)
    * 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar，或sun.boot.class.path路径下的内容），是用原生代码来实现的，并不继承自java.lang.ClassLoader。
    * 加载扩展类和应用程序类加载器。并指定他们的父类加载器。
* 扩展类加载器（extensions class loader）（为应用程序类加载器父类）
    * 用来加载Java的扩展库（JAVA_HOME/jre/ext/*.jar，或java.ext.dirs路径下的内容）。
    * Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
    * 由sun.misc.Launcher$ExtClassLoader实现
* 应用程序类加载器（application class loader）
    * 它根据Java应用的类路径（classpath，java.class.path路类。
    一般来说，Java应用的类都是由它来完成加载的。
    * 由sun.misc.Launcher$AppClassLoader实现
* 自定义类加载器
    * 开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。

#### java.class.ClassLoader
作用：
* java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。
* 除此之外，ClassLoader还负责加载Java应用所需的资源，如图像文件和配置文件等。

相关方法：

对于以上给出的方法，表示类名称的name参数的值是类的二进制名称。需要注意的是内部类的表示，如com.example.Sample\$1和com.example.Sample\$Inner等表示方式。

##### 代理模式
交给其他加载器来加载指定的类
##### 双亲委托机制
就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

双亲委托机制是为了保证Java核心库的类型安全。
* 这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。
-类加载器除了用于加载类，也是安全的最基本的屏障。

双亲委托机制是代理模式的一种
* 并不是所有的类加载器都采用双亲委托机制。
* tomcat服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的

#### 自定义类加载器的流程
继承：java.lang.ClassLoader
* 首先检查请求的类型是否已条被这个类装载器装载到命名空间中了，如果已经装载，直接返回；
* 委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；
* 调用本类加载器的findClass（）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（.…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…），loadClass（.…）转抛异常，终止加载过程

注意：被两个类加载器加载的同一个类，JVM不认为是相同的类。

#### 线程上下文类加载器
通常当你需要动态加载资源的时候，你至少有三个ClassLoader可以选择：
1. 系统类加截器或叫作应用类记载器（system classloader or application ciassloader）
2. 当前类加载器
3. 当前线程类加载器

线程类加载器是为了抛弃双亲委派加载链模式。
每个线程都有一个关联的上下交类加载器，如果你使用new Thread()方式生成新的线程，新线程将继承其父线程的上下文类加载器，如果程序对线程上下文类加载器没有任何改动的语，程序中所有的线程将都使用系统类加载器作为上下文类加载器。
Thread.currentThread().getContextClassLoader()
Thread.currentThread().setContextClassLoader()