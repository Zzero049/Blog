# 分布式锁三种实现方式：

\1. 基于数据库实现分布式锁；

\2. 基于缓存（Redis等）实现分布式锁；

\3. 基于Zookeeper实现分布式锁；

**一， 基于数据库实现分布式锁**

\1. 悲观锁

### 2.第一种实现

当想要锁住某个方法时执行ins ert方法，插入一条数据，method_name有唯一约束，可以保证多次提交只有一次成功，而成功的这次就可以认为其获得了锁，而执行完成后执行delete语句释放锁

缺点:

这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。

这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。

这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。

这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。

### 3.第二种实现

还是使用上方的表结构，可以通过数据库的排他锁来实现分布式锁

在查询语句后面增加`for update`，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。

我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过`connection.commit();`操作来释放锁

利用select … where … for update 排他锁

for update是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行

注意: 其他附加功能与实现一基本一致，这里需要注意的是“where name=lock ”，name字段必须要走索引，否则会锁表。有些情况下，比如表不大，mysql优化器会不走这个索引，导致锁表问题。

```java
public boolean lock(){

connection.setAutoCommit(false)

while(true){

try{

result = select * from methodLock where method_name=xxx for update;

if(result==null){

return true;

}

}catch(Exception e){

 

}

sleep(1000);

}

return false;
}


public void unlock(){

connection.commit();

}

 
```



\2. 乐观锁

所谓乐观锁与前边最大区别在于基于CAS思想，是不具有互斥性，不会产生锁等待而消耗资源，操作过程中认为不存在并发冲突，只有update version失败后才能觉察到。我们的抢购、秒杀就是用了这种实现以防止超卖。

通过增加递增的版本号字段实现乐观锁

![img](https://gitee.com/zero049/MyNoteImages/raw/master/202004150934531.png)

![img](https://gitee.com/zero049/MyNoteImages/raw/master/202004150934532.png)

问题：

1、获取锁和更新锁都是通过直接访问数据库得到的，在秒杀等高并发的场景无疑是雪上加霜

2、如果在服务过程中，一台tomcat（JVM）发生宕机了，那么其他服务器无法再拿到这个锁了，出现**死锁现象**

![image-20200601193840284](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200601193840284.png)

优化

![image-20200601194259969](H:\Desktop\新建文件夹\Blog\docs\backend\Zookeeper\pictures\image-20200601194259969.png)

但是依然有问题

1、监控的JVM4也可能挂掉，如果增加几个监控的JVM 一是资源浪费，二是监控状态的同步问题会变得很复杂

2、如果JVM1发生GC而等待，超过了一个JVM4的预期释放锁的时间，那么假设JVM2拿到了这个锁，此时JVM1和JVM2都在操作火车票的库存，**超卖问题**！

3、超时时间难以确定

过长：单位时间内不能卖出更多的票

过短：超卖

**二， 基于缓存（Redis等）实现分布式锁**

\1. 使用命令介绍：

（1）SETNX

SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。

（2）expire

expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。

（3）delete

delete key：删除key

在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。

\2. 实现思想：

（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。

（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。

（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。



**三， 基于Zookeeper实现分布式锁**

ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

> （1）创建一个目录mylock；
> （2）线程A想获取锁就在mylock目录下创建临时顺序节点；
> （3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
> （4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
> （5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。

