## IO模型

要介绍同步IO与异步IO，得先介绍Unix5种I/O模型：
\1. 阻塞IO
\2. 非阻塞IO
\3. IO复用（select和poll）
\4. 信号驱动式IO(SIGIO)
\5. 异步IO(aio_系列函数)

5种IO模型都包含两个阶段：
\1. 等待数据准备好（等待数据从网络中到达，数据到达后，被复制到内核的缓冲区中）
\2. 从内核缓冲区向用户缓冲区复制数据

分别介绍不同的IO模型，并且使用UDP作为例子，因为UDP整个数据报要么已经收到，要么没有。

### 阻塞IO

使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种IO模型是同步的。



![image-20200922222143219](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200922222143219.png)



进程调用recvfrom，该系统调用直到数据报到达且被复制到应用进程的缓冲区或者发生错误才返回，常见的错误是系统调用被系统中断，

### 非阻塞IO

改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。B同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场(回到用户进程空间)，可以做他自己的事情。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)，因此它还是同步IO。

![image-20200922222203641](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200922222203641.png)

等待数据的阶段是非阻塞的，也就是当没有数据报准备好，recvfrom立即返回一个错误，但是当数据包准备好了，recvfrom将数据报从内核缓冲区复制到应用进程缓冲区后返回。

### IO复用

这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是阻塞于select或poll，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有阻塞于系统调用的IO操作(不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络IO来说确实很短暂)，如果按这样理解，这种IO模型也能称之为非阻塞IO模型，但是按POSIX来看，它也是同步IO，那么也和楼上一样称之为同步非阻塞IO吧。

这种IO模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候C同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是C同学一个个打开，往杯子里装水(recv)。这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，主要区别在于舍管阿姨会告诉C同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。

![image-20200922222246881](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200922222246881.png)

如图，io复用模型是阻塞在select或者poll这两个系统调用之上的，而没有阻塞在真正的I/O系统调用如recvfrom之上，它等待数据报套接字变为可读，当数据报可读时，调用recvfrom把数据报复制到应用进程缓冲区中。

### 信号驱动式IO

通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv)。D同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(省不了装水的时间啊)。

![image-20200922222326010](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200922222326010.png)

通过sigaction系统调用安装一个信号处理函数，系统调用立即返回，当数据报准备好读取时，内核产生一个信号，随后就可以在信号处理函数中调用recvfrom读取数据报，将数据从内核空间复制到用户空间。

### 异步IO

调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情(没有recv)，这才是真正的异步IO。

![image-20200922222344237](https://gitee.com/zero049/MyNoteImages/raw/master/image-20200922222344237.png)

调用aio_系列函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，该系统调用立即返回，当整个IO操作完成，即数据报到达，并且从内核缓冲区被复制到用户缓冲区后，才产生一个信号。

进程发起read操作之后，立刻就可以开始去做其它的事。