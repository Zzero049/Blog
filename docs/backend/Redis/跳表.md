# Zset跳表

zset底层的存储结构包括`ziplist`或`skiplist`，在同时满足以下两个条件的时候使用ziplist，其他时候使用skiplist，两个条件如下：

- 有序集合保存的元素数量小于128个
- 有序集合保存的所有元素的长度小于64字节

即当元素比较多或者单个元素很大，ziplist就会优化成skiplist

```bash
127.0.0.1:6381> zadd myZset 10 v1
(integer) 1
127.0.0.1:6381> type myZset
zset
127.0.0.1:6381> Object encoding myZset
"ziplist"
127.0.0.1:6381> zadd myZset 1 sadsalfjaskfjakfjdsfjdsakfjdskfjkdsfjkdsjfkdsjfdmncvmncmvncmnvsdifyur8iwqe,fnd,fnmdssdf
(integer) 1
127.0.0.1:6381> Object encoding myZset
"skiplist"

```



当ziplist作为zset的底层存储结构时候，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。ziplist实际上就可以理解为一个存放在**连续内存空间上的双向列表**，其每一个节点都包含了前置指针和后置指针，只是经过了特殊的编码步骤了的。

![img](https://gitee.com/zero049/MyNoteImages/raw/master/1564320451474.png)

当skiplist作为zset的底层存储结构的时候，**使用skiplist按序保存元素及分值，使用dict来保存元素和分值的映射关系**。



## skiplist数据结构

skiplist 编码的有序集合对象使用 zet 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳表

![](https://gitee.com/zero049/MyNoteImages/raw/master/20200922182155.png)

```c
typedef struct zset{
     //跳跃表
     zskiplist *zsl;
     //字典
     dict *dice;
} zset;
```

字典的键保存元素的值，字典的值则保存元素的分值；跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。

这两种数据结构会**通过指针来共享相同元素的成员和分值**，所以不会产生重复成员和分值，造成内存的浪费。

> **说明**：其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以**每次进行范围操作的时候都要进行排序**；假如我们单独使用跳跃表来实现，虽然能执行范围操作，**但是查找操作由 O(1)的复杂度变为了O(logN)**。因此**Redis使用了两种数据结构来共同实现有序集合。**



### 跳跃表

**为什么使用跳跃表**

　　因为 zset 要支持随机的 插入 和 删除，所以它 不宜使用数组来实现，关于排序问题，我们也很容易就想到 红黑树/平衡树 这样的树形结构，为什么 Redis 不使用这样一些结构呢？

1. 性能考虑：在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部
2. 实现考虑：在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；

　　基于以上的一些考虑，Redis 基于 **William Pugh** 的论文做出一些改进后采用了 **跳跃表** 这样的结构。

　我们需要这个链表按照 score 值进行排序，这也就意味着，当我们需要添加新的元素时，我们需要定位到插入点，这样才可以继续保证链表是有序的，通常我们会使用 **二分查找法**，但二分查找是有序数组的，链表没办法进行位置定位，我们除了遍历整个链表找到第一个比给定数据大的节点为止*（时间复杂度 O(n))* 似乎没有更好的办法。

　　但假如我们每相邻两个节点之间就增加一个指针，让指针指向下一个节点，如下图：

![img](https://gitee.com/zero049/MyNoteImages/raw/master/980882-20200603092430916-1137203799.png)

　　这样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半（如图中的数字：3，11）

　　现在假设我们想要查找数据时，可以根据这条新的链表查找，如果碰到比待查找数据大的节点时，再回到原来的链表中进行查找，比如，我们想要查找 7，查找的路径则是沿着下图中标注出的红色指针所指向的方向进行的：（下图第二、三步错了，是3下一个节点为11大于7，因此不能走，所以往下走）

![img](https://gitee.com/zero049/MyNoteImages/raw/master/980882-20200603093017733-2095387841.png)

　　这是一个略微极端的例子，但我们仍然可以看到，通过新增加的指针查找，我们不再需要与链表上的每一个节点逐一进行比较，这样改进之后需要比较的节点数大概只有原来的一半。

　　利用同样的方式，我们可以在新产生的链表上，继续为每两个相邻的节点增加一个指针，从而产生第三层链表：

![img](https://gitee.com/zero049/MyNoteImages/raw/master/980882-20200603093245828-1880172643.png)

在这个新的三层链表结构中，我们试着 **查找 13**，那么沿着最上层链表首先比较的是 11，发现 11 比 13 小，于是我们就知道只需要到 11 后面继续查找，**从而一下子跳过了 11 前面的所有节点。**

　　可以想象，当链表足够长，这样的多层链表结构可以帮助我们跳过很多下层节点，从而加快查找的效率。

#### 更进一步的跳跃表

　　**跳跃表 skiplist** 就是受到这种多层链表结构的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 _O(logn)_。

　　但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的 2:1 的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点 *（也包括新插入的节点）* 重新进行调整，这会让时间复杂度重新蜕化成 _O(n)_。删除数据也有同样的问题。

　　**skiplist** 为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是 **为每个节点随机出一个层数(level)**。比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个 skiplist 的过程：

![img](https://gitee.com/zero049/MyNoteImages/raw/master/980882-20200603093914923-1869637053.png)

　从上面的创建和插入的过程中可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此，**插入操作只需要修改节点前后的指针，而不需要对多个节点都进行调整**，这就降低了插入操作的复杂度。

　　现在我们假设从我们刚才创建的这个结构中查找 23 这个不存在的数，那么查找路径会如下图：

![img](https://gitee.com/zero049/MyNoteImages/raw/master/980882-20200603094520103-92218856.png)

**redis中的随机层数**

　　对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数，源码在 `t_zset.c/zslRandomLevel(void)` 中被定义：

```
int zslRandomLevel(void) { 
    int level = 1; 
    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
         level += 1; 
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; 
}
```

```c
p = 1/4
MaxLevel = 32
```

​		这里redis设置最大层数是32，概率是1/4

　　因为 **Redis 跳跃表默认允许最大的层数是 32**，被源码中 `ZSKIPLIST_MAXLEVEL` 定义，当 `Level[0]` 有 264 个元素时，才能达到 32 层，所以定义 32 完全够用了。



数学的概念来解释，就是如果一个新建的节点有 50% 的概率被分配到 Level 1，25% 的概率被分配到 Level 2，12.5% 的概率被分配到 Level 3，以此类推…有 2^-63^的概率被分配到最顶层，因为这里每一层的晋升率都是 50%。只有当第一层节点数量达到是2^64^时，也就是说层数到达32时，才可能被分到最顶层，因此，跳跃表的层数最大只能到达32层，这也被源码`ZSKIPLIST_MAXLEVEL` 定义了。

## **小结**

跳跃表的插入与删除至此都讲完了，总结下跳跃表的有关性质：

(1). 跳跃表是一种随机化的数据结构(通过抛硬币来决定层数)。

(2). 跳跃表的每一层都是一条**有序的链表**.

(3). 最底层的链表包含所有元素。

(4). 跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)。

(5). 跳跃表的空间复杂度为 O(n)。