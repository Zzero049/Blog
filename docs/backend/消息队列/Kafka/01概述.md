# Kafka概述

Kafka是一个**分布式**的基于**发布/订阅模式的消息队列**（Message Queue），主要应用于大数据实时处理领域。(与Spark对接)

## 消息队列

### 传统消息队列应用场景

想象一下修手机，一种情况是在手机店等修好了拿，另一种方式是等他修好了通知你过去拿

![image-20201002122731397](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201002122731397.png)

**使用消息队列的好处**

1. **解耦**

   允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束

2. **可恢复性**
   系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理

3. **缓冲**

   有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况 。

4. **灵活性（可动态装拆） & 峰值处理能力**
   在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。（QPS不是全部打到服务器上，而是部分放入消息队列）
5. **异步通信**
   很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。  



### 消息队列的两种模式

**1、点对点模式**（**一对一**，消费者主动拉取数据，**消息收到后消息清除**）

​	消息生产者生产消息发送到Queue中， 然后消息消费者从Queue中取出并且消费消息。消息被消费以后， queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。  

![image-20201002123854729](pictures/image-20201002123854729.png)

**2、发布/订阅模式**（一对多，消费者消费数据之后不会清除消息）

​	消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。  

​	发布订阅又分两种，一种是消费者主动拉取消息（Kafka，客户端忙轮询查队列有没有消息），另一种是MQ主动推送（MQ与消费者处理能力不一，出现资源浪费或者客户端崩了，性能由MQ和消费者处理能力决定）。

![image-20201002124107243](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201002124107243.png)



## Kafka基础架构

Broker是服务器，里面运行着Kafka实例，里面有很多topic对消息进行分类

下面是消息A-0和A-1做了分区进行负载均衡，B-0没有进行主从复制

消费者有又可以组成消费者组，同一个分区的数据只能被组内的一个消费者消费，即可以把一个组看成一个消费者

Zookeeper帮助Kafka集群存储一些信息，帮消费者存储一些信息

![image-20201002125242543](https://gitee.com/zero049/MyNoteImages/raw/master/image-20201002125242543.png)

**1） Producer ：** 消息生产者，就是向 kafka broker 发消息的客户端；

**2） Consumer ：** 消息消费者，向 kafka broker 取消息的客户端；

**3） Consumer Group （CG）：** 消费者组，由多个 consumer 组成。 消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。 所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。

**4） Broker ：** 一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个 topic。

**5） Topic ：** 可以理解为一个队列， 生产者和消费者面向的都是一个 topic；

**6） Partition：** 为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；

**7） Replica：** 副本，为保证集群中的某个节点发生故障时， 该节点上的 partition 数据不丢失，  且 kafka 仍然能够继续工作， kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。

**8） leader：** 每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。

**9） follower：** 每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。 leader 发生故障时，某个 follower 会成为新的  